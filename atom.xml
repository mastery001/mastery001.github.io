<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>locoder&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ziwenzou.com/"/>
  <updated>2017-11-11T14:56:50.457Z</updated>
  <id>http://blog.ziwenzou.com/</id>
  
  <author>
    <name>locoder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习算法汇总</title>
    <link href="http://blog.ziwenzou.com/2017/11/04/2017-11-04-machine_learning_algorithm/"/>
    <id>http://blog.ziwenzou.com/2017/11/04/2017-11-04-machine_learning_algorithm/</id>
    <published>2017-11-03T16:00:00.000Z</published>
    <updated>2017-11-11T14:56:50.457Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习算法的分类以及详细介绍<br><a id="more"></a></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="Mathematical-formulation"><a href="#Mathematical-formulation" class="headerlink" title="Mathematical formulation"></a>Mathematical formulation</h2><h3 id="L-P范数"><a href="#L-P范数" class="headerlink" title="L-P范数"></a>L-P范数</h3><p>范数是一种强化了的距离概念。包括</p><ol><li>向量范数：向量空间中向量的大小</li><li>矩阵范数：矩阵引起的变化的大小</li></ol><p>公式定义：$Lp=\sqrt[p]{\sum\limits_{1}^n  x_i^p}，x=(x_1,x_2,\cdots,x_n)$</p><p>根据P 的变化，范数也有着不同的变化，一个经典的有关P范数的变化图如下：<br><img src="http://img.blog.csdn.net/20160623222921977" alt="这里写图片描述"></p><ol><li><p>当p=0时，即L0范数，主要被用来度量向量中非零元素的个数</p></li><li><p>当p=1时，即L1范数(也被称作稀疏规则算子—Lasso regularization)，表示向量x中非零元素的绝对值之和；主要用来度量两个向量间的差异；(曼哈顿距离、最小绝对误差) 如绝对误差和(Sum of Absolute Difference)</p><script type="math/tex; mode=display">SAD(x_1,x_2) = \sum_i \left|x_{1i} - x_{2i}\right|</script></li><li><p>当p=2时，即L2范数，表示向量元素的平方和再开方。常见的L2范数有欧式距离公式，或如平方差和(Sum of Squared Difference)</p><script type="math/tex; mode=display">SAD(x_1 , x_2) = \sum_i (x_{1i} - x_{2i})^2</script></li><li><p>当p=∞时，也就是L-∞范数，主要被用来度量向量元素的最大值</p><p>​</p></li></ol><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习(supervised learning)：利用样本输入和期望输出来学习如何预测的技术</p><ol><li>K-近邻</li><li>决策树(decision trees)</li><li>梯度下降/上升(gradient-descent / gradient-boosted )</li><li>逻辑回归(logistis regression)</li><li>贝叶斯过滤(naive Bayes)</li><li>交替最小二乘法(Alternative least squares)</li><li>支持向量机(SVMs)</li><li>随机森林(random forests)</li><li>神经网络</li></ol><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>无监督学习(unsupervised learning)：从一组数据中找寻某种结构</p><ol><li>聚类</li><li>负矩阵因式分解(non-negative matrix factorization)</li><li>自组织映射(self-organizing maps)</li></ol><h1 id="ML步骤"><a href="#ML步骤" class="headerlink" title="ML步骤"></a>ML步骤</h1><ol><li>收集数据，筛选特征</li><li>模型算法选取</li><li>生成cost function，得出假设函数</li><li>新值代入假设函数</li></ol><h1 id="K-近邻"><a href="#K-近邻" class="headerlink" title="K-近邻"></a>K-近邻</h1><p>步骤如下：</p><ol><li>计算已知类别数据集中的点与当前点的距离(欧式距离公式)</li><li>按照距离递增排序</li><li>选取与当前点距离最小的前k个点</li><li>确定前k个点所在类别出现的概率</li><li>返回前k个点出现概率最高的类别(即当前点预测分类)</li></ol><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>假设有n个特征，依次根据数据增益情况求出最优特征，然后根据特征求出对应的分支</p><ol><li>根据数据集选取出最佳特征</li><li>计算该特征对应的值分别对应的结果标签—- 可能是结果标签，也可能是其他特征的决策树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习算法的分类以及详细介绍&lt;br&gt;
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.ziwenzou.com/categories/machine-learning/"/>
    
    
      <category term="ml" scheme="http://blog.ziwenzou.com/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>集体智慧编程笔记</title>
    <link href="http://blog.ziwenzou.com/2017/10/29/2017-10-29-collective_intelligence_notes/"/>
    <id>http://blog.ziwenzou.com/2017/10/29/2017-10-29-collective_intelligence_notes/</id>
    <published>2017-10-28T16:00:00.000Z</published>
    <updated>2017-11-11T14:56:00.495Z</updated>
    
    <content type="html"><![CDATA[<p>阅读集体智慧编程所做的一些笔记<br><a id="more"></a></p><h1 id="集体智慧导言"><a href="#集体智慧导言" class="headerlink" title="集体智慧导言"></a>集体智慧导言</h1><p><strong>集体智慧</strong>：为了创造新的想法，而将一群人的行为、偏好和思想组合在一起</p><p><strong>机器学习</strong>：是人工智能（AI,artificial intelligence）领域中和算法相关的一个子域，它允许机器不断地学习。大多数情况下，将一组数据传递给算法，由算法推断出与这些数据的属性相关的信息。数据-&gt;训练-&gt;模型-&gt;预测-&gt;结果。</p><ul><li>局限性：只能凭借已有数据进行归纳训练，而且归纳方式也有局限性</li></ul><h1 id="提供推荐"><a href="#提供推荐" class="headerlink" title="提供推荐"></a>提供推荐</h1><h2 id="协作型过滤"><a href="#协作型过滤" class="headerlink" title="协作型过滤"></a>协作型过滤</h2><p><strong><em>Collaborative filtering</em></strong>：对一大群人进行搜索，并从中找出品味相近的一小群人</p><p>条件：人、特征、特征值</p><p>相似度计算函数(值越大，相似度越高)：</p><ol><li>欧几里得距离：当距离越大，则偏好越近；当=1时则代表偏好相同<script type="math/tex; mode=display">\frac{1}{1+\sqrt{\left({x_2-x_1}\right)^2 +  \left({y_2-y_1}\right)^2}}</script>​</li><li><p>皮尔逊相关度：判断两组数据与某一直线<strong>拟合程度</strong>的一种度量。</p><ul><li>找出两者都存在的特征</li><li>计算两者特征值总和(sum1,sum2)、平方总和(sumSq1,sumSq2)以及乘积之总和(pSum)</li><li>之后按如下公式进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算皮尔逊评价值</span></span><br><span class="line">num = pSum - (sum1 * sum2 / n)</span><br><span class="line">den = sqrt((sumSq1 - pow(sum1 , <span class="number">2</span>) / n) * (sumSq2 - pow(sum2 , <span class="number">2</span>) / n))</span><br><span class="line"><span class="keyword">if</span> den == <span class="number">0</span> : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">r = num / den</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">num = pSum - \frac{sum1-sum2}{n}</script><script type="math/tex; mode=display">den = \sqrt{\left(sumSq1 - \frac{sum1^2}{n}\right) * \left(sumSq2 - \frac{sum2^2}{n}\right) }</script></li><li><p>曼哈顿距离算法</p></li><li><p>Jaccard/Tanimoto系数(Tanimoto coefficient)：数据中交集和并集的比例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">若数据集中取值只有0或1，则可定义度量如下</span></span><br><span class="line"><span class="string">下列代码使用1-系数的作用是使得值越小代表相似度越高</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanimoto</span><span class="params">(v1 , v2)</span> :</span></span><br><span class="line">    c1 , c2 , shr = <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(v1)) :</span><br><span class="line">        <span class="keyword">if</span> v1[i] != <span class="number">0</span> : c1 += <span class="number">1</span> <span class="comment"># 出现在v1中</span></span><br><span class="line">        <span class="keyword">if</span> v2[i] != <span class="number">0</span> : c2 += <span class="number">1</span> <span class="comment"># 出现在v2中</span></span><br><span class="line">        <span class="keyword">if</span> v1[i] != <span class="number">0</span> &amp;&amp; v2[i] != <span class="number">0</span> : shr += <span class="number">1</span> <span class="comment"># 同时出现在v1和v2中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> - (float(shr) / (c1 + c2 - shr))</span><br></pre></td></tr></table></figure><p>  ​</p></li><li><p>互信息系数：度量非线性相关性</p></li><li><p><a href="https://en.wikipedia.org/wiki/Metric_%28mathematics%29#Examples" target="_blank" rel="external">更多相似度计算函数</a></p></li></ol><h3 id="推荐用户"><a href="#推荐用户" class="headerlink" title="推荐用户"></a>推荐用户</h3><ol><li>通过相似度计算函数计算除当前用户外的所有用户的相似度</li><li>将相似度值从大到小依次排序</li><li>取得前n个结果</li></ol><h3 id="推荐物品"><a href="#推荐物品" class="headerlink" title="推荐物品"></a>推荐物品</h3><ol><li>构建相似度表</li></ol><div class="table-container"><table><thead><tr><th>用户</th><th>相似度</th><th>物品</th><th>S.x物品</th></tr></thead><tbody><tr><td>xxx</td><td>取值为0~1</td><td>用户评价值</td><td>用户评价值 * 相似度</td></tr><tr><td>总计</td><td></td><td></td><td>$\sum_{i=1}^n s_i$</td></tr><tr><td>Sim.Sum</td><td></td><td></td><td>相似度之和(该用户所有评论的物品)</td></tr><tr><td>总计/Sim.Sum</td><td></td><td></td><td>.</td></tr></tbody></table></div><ol><li>将相似度表从大到小排序</li></ol><h1 id="发现群组"><a href="#发现群组" class="headerlink" title="发现群组"></a>发现群组</h1><h2 id="分级聚类"><a href="#分级聚类" class="headerlink" title="分级聚类"></a>分级聚类</h2><p>分级聚类：通过连续不断地将最为相似的群组两两合并，来构造出一个群组的层级结构（每个群组都是由单一元素开始的）</p><p><strong>群组数据结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">聚类群组(层级树)：以树状结构表示</span></span><br><span class="line"><span class="string">可通过PIL(Python Imaging Library)进行树状图绘制</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bicluster</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , vec , left = None , right = None , distance = <span class="number">0.0</span> , id = None)</span>:</span></span><br><span class="line">        self.vec = vec <span class="comment"># 数据集，两个群组合并后的数据集为其均值</span></span><br><span class="line">        self.left = left <span class="comment"># 左节点</span></span><br><span class="line">        self.right = right<span class="comment"># 右节点</span></span><br><span class="line">        self.id = id<span class="comment"># 聚类唯一id，合并聚类的id为负数</span></span><br><span class="line">        self.distance = distance<span class="comment"># 群组的距离</span></span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><ol><li>初始化聚类群组列表(数据集的每一行为一个群组)</li><li><code>loop start</code>：计算每个群组间的距离（可参考上述的<a href="/" title="协作型过滤">相似度计算函数</a>），找到距离最小的两个群组x和y</li><li>计算距离最小的两个群组的<code>均值</code>—&gt;作为新群组的数据集</li><li>构造新群组</li><li>从群组列表中删除x和y，并将新群组加入到群组列表中 <code>loop end</code></li><li>返回群组列表第一个元素 —&gt;其为聚类最终结果</li></ol><p><strong>缺点</strong></p><ol><li>在没有额外投入的情况下，树状图不会真正将数据拆分到不同组</li><li>该算法的计算量很大，时间复杂度为$n^3$</li></ol><h2 id="K-均值聚类"><a href="#K-均值聚类" class="headerlink" title="K-均值聚类"></a>K-均值聚类</h2><p>K-均值聚类：在分级聚类的基础上添加k个中心点的概念，即最终确定的聚类是k个，而非1个</p><p><strong>步骤</strong></p><ol><li>随机确定k个中心位置，</li><li><code>loop start</code>：将各个群组分配到最临近的中心点；</li><li>分配完成后，聚类中心点会移动到该聚类的的所有节点的平均位置处 </li><li>当分配过程不再发生变化，结束循环<code>loop end</code></li></ol><h1 id="搜索与排名"><a href="#搜索与排名" class="headerlink" title="搜索与排名"></a>搜索与排名</h1><p>构建搜索引擎的步骤一般如下：</p><ol><li><p><strong>数据搜集</strong>：获取网页url、内嵌网页等</p></li><li><p><strong>建立索引</strong>：创建网页中单词与网页的索引，附属信息有：位置及归属网页等</p></li><li><p><strong>搜索排名</strong>：根据单词搜索结果，使用不同的度量方法进行排名；方法有以下几种</p><ul><li><p>基于内容排名</p><ul><li>单词频度</li><li>文档位置</li><li>单词距离</li></ul></li><li><p>利用外部回指链接</p><ul><li>简单计数法</li></ul></li></ul></li></ol><pre><code> - PageRank算法 - 基于链接文本的pr值</code></pre><ul><li>基于点击行为的神经网络</li></ul><h2 id="归一化函数"><a href="#归一化函数" class="headerlink" title="归一化函数"></a>归一化函数</h2><p>对于评价值来说，其特点有值区间不确定性、可比较性差；为了让其具有相同的值域和变化方向，需要对结果归一化处理。</p><p>而评价值的大小比较，取决于评价方法而定，有的评价方法评分值越大越好，有的则越小越好。</p><p>下列是该书中的归一化处理函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalizescores</span><span class="params">(self , scores , smallIsBetter = <span class="number">0</span>)</span>:</span></span><br><span class="line">       vsmall = <span class="number">0.00001</span> <span class="comment"># 避免被零整除</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 当值越小时，评价值越高</span></span><br><span class="line">       <span class="keyword">if</span> smallIsBetter :</span><br><span class="line">           minscore = min(scores.values())</span><br><span class="line">           <span class="keyword">return</span> dict([(u , float(minscore) / max(vsmall , l)) <span class="keyword">for</span> u , l <span class="keyword">in</span> scores.items()])</span><br><span class="line">       <span class="keyword">else</span> :</span><br><span class="line">           maxscore = max(scores.values())</span><br><span class="line">           <span class="keyword">if</span> maxscore == <span class="number">0</span> : maxscore = vsmall</span><br><span class="line">           <span class="keyword">return</span> dict([(u, float(c) / maxscore) <span class="keyword">for</span> u, c <span class="keyword">in</span> scores.items()])</span><br></pre></td></tr></table></figure><p>归一化资料可参考：</p><ul><li><a href="[http://www.jianshu.com/p/3e6742f1b77c](http://www.jianshu.com/p/3e6742f1b77c">离差标准化和Z-Score标准化</a>)</li><li><a href="http://blog.csdn.net/pipisorry/article/details/52247379" target="_blank" rel="external">数据的标准化和归一化</a></li></ul><h2 id="基于内容排名"><a href="#基于内容排名" class="headerlink" title="基于内容排名"></a>基于内容排名</h2><p>顾名思义，将网页搜索结果根据网页内容进行评价，根据评价结果进行排名</p><h3 id="单词频度"><a href="#单词频度" class="headerlink" title="单词频度"></a>单词频度</h3><p>单词频度：根据搜索词在网页中出现的次数对网页进行评价</p><p><strong>缺陷</strong>：若搜索词在某个网页中出现次数很多，可是该网页却不是最优结果</p><h3 id="文档位置"><a href="#文档位置" class="headerlink" title="文档位置"></a>文档位置</h3><p>文档位置：根据搜索词在文档中的位置之和进行评价，位置越靠前评价值越高</p><h3 id="单词距离"><a href="#单词距离" class="headerlink" title="单词距离"></a>单词距离</h3><p>单词距离：根据查询的多个搜索词在网页中的距离之和进行评价，距离越小评价值越高</p><h2 id="利用外部回指链接"><a href="#利用外部回指链接" class="headerlink" title="利用外部回指链接"></a>利用外部回指链接</h2><h3 id="简单计数"><a href="#简单计数" class="headerlink" title="简单计数"></a>简单计数</h3><p>简单计数：根据网页被其他网页引用次数进行评价，引用次数越多评价值越高</p><h3 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h3><p>PageRank算法由Google创始人(以Larry Page命名)发明，该算法为每个网页都赋予了一个指示网页重要程度的评价值</p><p><strong>计算公式</strong>：</p><p>假设有A,B,C,D四个网页，那么PR(A)的计算公式如下：</p><pre><code>PR(A) = 0.15 + 0.85 * (PR(B) / linkcount(B) + PR(C) / linkcount(C) + PR(C) / linkcount(C))</code></pre><p>阻尼因子=0.85，指示用户持续点击每个网页中链接的概率为85%</p><h3 id="利用链接文本"><a href="#利用链接文本" class="headerlink" title="利用链接文本"></a>利用链接文本</h3><p>利用链接文本：根据网页的链接文本来决定网页的相关程度</p><p>描述：根据搜索词得到网页A和B，A-&gt;B，若B在搜索结果列表中，则把B的评价值加上A的pr值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">搜索结果列表</span><br><span class="line"><span class="keyword">for</span> 搜索词 <span class="keyword">in</span> 搜索词列表 :</span><br><span class="line">获取搜索词对应的网页链接关系表[(<span class="keyword">from</span> , to) , ...]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">from</span> , to) <span class="keyword">in</span> [(<span class="keyword">from</span> , to) , ...]:</span><br><span class="line">        <span class="keyword">if</span> to <span class="keyword">in</span> 搜索结果列表 :</span><br><span class="line">            pr = pr(<span class="keyword">from</span>)</span><br><span class="line">            搜索结果列表[to] += pr</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>solve：协作类问题</p><p>擅长处理：受多种变量影响，存在许多可能解的问题，以及结果因这些变量的组合而产生很大变化的问题</p><p>优化算法是通过尝试许多<strong>不同题解</strong>并给这些题解打分以确定其质量的方式来找到一个问题的最优解。</p><p>步骤：</p><ol><li>描述题解</li><li>确定成本函数(The Cost Function)</li><li>选取优化算法</li></ol><h2 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h2><p>算法思想：构造可能出现的解题输入参数组合，并代入到成本函数，将每组解进行比较，得到最优解（如下图，从所有题解中找到最优解—这里只标记了几个局部最优解，进行比较）</p><p>缺点：该算法是到处跳跃的(jumps around)，非常低效；其不会自动寻找已经发现的最优解相近的题解</p><h2 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h2><p>算法思想：从一个随机搜索题解开始，然后在其临近的题解中寻找最优解；下图中假设找到红点A，将临近往上或往下的点进行解计算后，找到更优解，重复该步骤，直到邻近的解都比该解大，则认为是该点是最优解</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkpxkh92d7j30ws0f0aam.jpg" alt=""></p><p>对比：相较于随机搜索，其具有更低的成本</p><p>缺点：算法结果得到的其实不是全局最优解，而是局部最优解(类似于Gradient descent)</p><p>为了得到全局最优解，其算法有个更好的替代方案—随机重复爬山法(random-restart hill climbing),即让爬山法以多个随机生成的初始解为起点运行若干次，借此希望其中有一个解能逼近全局最优解</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fkq68mus6lj30ft08lt8v.jpg" alt=""></p><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><p>退火：将合金加热后再慢慢冷却的过程</p><p>算法思想：以一个问题随机解开始，通过退火期间的迭代，随机选取题解中的某个数字，然后朝某个方向变化；算法执行过程中实际计算当前题解和新题解(即随机选取的数字计算的解)，当新题解优于当前题解时，则新题解替换当前题解；若新题解劣于当前题解，则需要判断新题解是否在<code>可接受</code>范围，若可接受，则替换当前题解</p><p>退火过程如下：</p><p>条件 —&gt; 温度(temperature) , 冷却因子(coolfactor)</p><p>公式 —&gt; <code>temperature = temperature * coolfactor</code></p><p>接受范围值计算公式：</p><script type="math/tex; mode=display">p = e^{(-(highcost - lowcost) / temperature)}</script><p> 由于初始温度很高，所以p初始时将无限趋近于1，随着题解的差异越来越大，概率越来越低，因此该算法更倾向于稍差的解，而不会是最差的解</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p : 可能的题解范围</span></span><br><span class="line"><span class="string">costfunction : 成本计算函数</span></span><br><span class="line"><span class="string">t : 初始温度</span></span><br><span class="line"><span class="string">cf : 冷却因子</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annealingoptimize</span><span class="params">(p , costfunction , t , cf)</span> :</span></span><br><span class="line">    <span class="keyword">while</span> t &gt; <span class="number">0.1</span> :</span><br><span class="line">        i <span class="comment"># 当前题解参数</span></span><br><span class="line">        j <span class="comment"># 新题解参数</span></span><br><span class="line">        <span class="comment"># 计算当前题解</span></span><br><span class="line">        currentcost = costfunction(i)</span><br><span class="line">        <span class="comment"># 移动方向，计算新题解</span></span><br><span class="line">        newcost = costfunction(j)</span><br><span class="line">        <span class="comment"># 这里为什么使用random.random()? </span></span><br><span class="line">        <span class="comment"># 因为如果使用上一次的p，则大概率的可能只能求取到局部最优解</span></span><br><span class="line">        <span class="keyword">if</span> newcost &lt; currentcost <span class="keyword">or</span> random.random() &lt; pow(math.e , - (newcost - currentcost) / t ) :</span><br><span class="line">            currentcost = newcost</span><br><span class="line">        t = t * cf</span><br></pre></td></tr></table></figure><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p>算法思想：通过成本函数建立种群，在种群中通过精英选拔法(elitism)得到最优解，种群剩余的解再通过修改题解的参数得到全新的题解，两者组合得到新种群；通过重复以上过程n次后，最终得到的题解为最优解</p><p>名词概念：</p><ul><li>种群(population)：随机生成一组解</li><li>精英选拔法：种群中位于最顶层的题解</li><li>修改题解<ul><li>变异(mutation)：对现有解进行微小的、简单的、随机的改变</li><li>交叉(crossover)或配对(breeding)：随机选取两个解，并将两者按某种方式进行结合</li></ul></li></ul><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">popsize : 群组解个数</span></span><br><span class="line"><span class="string">costfunction : 成本函数</span></span><br><span class="line"><span class="string">n : 迭代次数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geneticoptimize</span><span class="params">(popsize , costfunction , n )</span> :</span></span><br><span class="line">    pop = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(popsize) :</span><br><span class="line">        pop.append(costfunction(i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n) :</span><br><span class="line">        <span class="comment"># 当前种群的最优题解</span></span><br><span class="line">        sorted(pop)</span><br><span class="line">        <span class="comment"># 创建新群组</span></span><br><span class="line">        newpop = []</span><br><span class="line">        <span class="comment"># 添加当前群组最优解</span></span><br><span class="line">        newpop.append(pop[:<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 添加当前群组剩余群组修改题解后的群组</span></span><br><span class="line">        remainpop = pop[<span class="number">1</span>:]</span><br><span class="line">        newpop.append(mutation(remainpop) <span class="keyword">or</span> crossover(remainpop))</span><br><span class="line">        </span><br><span class="line">        pop = newpop</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出最优解</span></span><br><span class="line">    <span class="keyword">return</span> pop[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="文档过滤"><a href="#文档过滤" class="headerlink" title="文档过滤"></a>文档过滤</h1><p>solve：通过算法学习并鉴别文档所属的分类</p><p>典型应用场景：</p><ul><li>自动划分邮件类别</li><li>垃圾邮件过滤</li></ul><p>早期的邮件过滤做法都是基于规则的分类器（rule-based classifiers）；事先定义好规则，例如单词黑名单、英文大写字母的过多使用等等</p><p>存在的问题：</p><ul><li>过滤不准确，正常邮件被认为是垃圾邮件</li></ul><p>文档分类的一般做法如下：</p><ol><li>收集现有的已分类好的文档数据作为训练数据</li><li>计算文档中单词在该分类的概率<code>P(word | category)</code></li><li>对2计算的概率作加权平均(当训练集过小时，会导致分类不准确)</li><li>通过学习算法计算文档属于分类的概率<code>P(category | document)</code><ul><li>朴素贝叶斯(NaiveBayes)</li><li>费舍尔方法(SpamBayes)</li></ul></li></ol><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>贝叶斯定理公式：</p><script type="math/tex; mode=display">P(A | B) = \frac{ P(B | A) * P(A) } {P(B)}</script><p><strong>使用贝叶斯的条件：A和B发生的概率是相互独立，不相关的</strong></p><p>代入到上述文档分类步骤：</p><ol><li>计算P(document | category)，即将该document所有的word出现在该category概率相乘</li></ol><script type="math/tex; mode=display">P(document | category) = \prod_i^n P(word_i | category)</script><ol><li>通过1计算的概率，代入到贝叶斯公式计算P(category | document)<script type="math/tex; mode=display">P(category | document) = \frac{P(document | category) * P(category)}{P(document)}</script></li></ol><p>限于算法计算的概率是依赖训练集的<code>丰富程度</code>的，所以对文档的分类会存在<code>不准确性</code>的；为了规避这种不准确性，可以设置一个分类划分的<code>阈值n</code>— 即算法得到的分类的概率值必须大于在其他分类中的概率的n倍</p><h2 id="费尔舍方法"><a href="#费尔舍方法" class="headerlink" title="费尔舍方法"></a>费尔舍方法</h2><p>费尔舍方法为文档中的每个特征都求得了分类的概率，然后又将这些概率组合起来，并判断其是否有可能构成一个随机集合。</p><p>步骤：</p><ol><li>通过已经计算好P(word | category)，来求出P(category | word)；常见方法是<code>(具有指定特征的属于某分类的文档数) / (具有指定特征的文档总数)</code><ul><li>属于某分类的概率<code>clf = P(word | category)</code></li><li>属于所有分类的概率<code>freqsum = P(word | category)</code>之和</li><li>最终概率<code>p = clf / freqsum</code></li></ul></li><li>算出文档中所有word的概率之积</li><li>去取自然对数再乘以-2；<code>score = -2 * log(p)</code></li><li>最后利用倒置对数卡方函数求得概率，得出该组概率的最大值—如果概率彼此独立且随机分布，则此计算结果满足<strong>对数卡方分布</strong>(chi-squared distribution)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读集体智慧编程所做的一些笔记&lt;br&gt;
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.ziwenzou.com/categories/machine-learning/"/>
    
    
      <category term="ml" scheme="http://blog.ziwenzou.com/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>推荐</title>
    <link href="http://blog.ziwenzou.com/2017/10/29/2017-10-29-recommendation/"/>
    <id>http://blog.ziwenzou.com/2017/10/29/2017-10-29-recommendation/</id>
    <published>2017-10-28T16:00:00.000Z</published>
    <updated>2017-11-11T14:56:56.896Z</updated>
    
    <content type="html"><![CDATA[<p>推荐的一些基本介绍</p><a id="more"></a><h1 id="什么是推荐"><a href="#什么是推荐" class="headerlink" title="什么是推荐"></a>什么是推荐</h1><p><strong>定义</strong>：根据群体偏好来向用户推荐相关的物品</p><p>例子：</p><ol><li>Amazon、淘宝通过对用户浏览、购买等行为记录后，并推荐可能喜欢的商品</li><li>网易云音乐的私人FM</li><li>美团APP上的猜你喜欢</li></ol><p>一般步骤：</p><ol><li>搜集用户行为数据</li><li>建立用户-物品评价值表</li><li>计算用户-用户之间或物品-物品之间的相似度值</li><li>提供相似度最高的推荐</li></ol><h2 id="协作型过滤"><a href="#协作型过滤" class="headerlink" title="协作型过滤"></a>协作型过滤</h2><p><strong><em>Collaborative filtering</em></strong>：对一大群人进行搜索，并从中找出品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考察，并将它们组合起来构造出一个经过排名的推荐列表</p><h1 id="基于用户推荐"><a href="#基于用户推荐" class="headerlink" title="基于用户推荐"></a>基于用户推荐</h1><p>用户-物品评价值表：</p><div class="table-container"><table><thead><tr><th></th><th>物品1</th><th>物品2</th><th>物品n</th></tr></thead><tbody><tr><td>用户1</td><td>3.5</td><td>4.5</td><td>4</td></tr><tr><td>用户2</td><td>4</td><td>3</td><td></td></tr><tr><td>用户3</td><td>3</td><td></td><td>4.5</td></tr><tr><td>用户4</td><td></td><td>4</td><td></td></tr><tr><td>用户5</td><td>3.5</td><td>4</td><td>4.5</td></tr></tbody></table></div><h2 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h2><p>基于用户-物品评价值表，我们可以计算出用户-用户之间的相似度评价值，有若干种方法可以计算。</p><ol><li>欧几里得距离：当距离越大，则偏好越近；当=1时则代表偏好相同</li><li>皮尔逊相关度：判断两组数据与某一直线<strong>拟合程度</strong>的一种度量。</li><li>曼哈顿距离算法</li><li>Jaccard/Tanimoto系数(Tanimoto coefficient)</li><li>互信息系数：度量非线性相关性</li><li><a href="https://en.wikipedia.org/wiki/Metric_%28mathematics%29#Examples" target="_blank" rel="external">更多相似度计算函数</a></li></ol><h3 id="欧几里得距离"><a href="#欧几里得距离" class="headerlink" title="欧几里得距离"></a>欧几里得距离</h3><p>在数学中，<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB" target="_blank" rel="external">欧几里得距离</a>是欧几里得空间中两点间’’普通“(即直线)距离。</p><script type="math/tex; mode=display">d = \sqrt{(x_2 - x_1)^2}</script><p>通过欧几里得公式我们可以计算基于用户-物品评价值表的<code>偏好空间</code>中用户与用户的距离，距离越近，则越相似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="comment"># useritems为用户-物品评价值表</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> useritems[u1] :</span><br><span class="line"><span class="keyword">if</span> item <span class="keyword">in</span> useritems[u2] :</span><br><span class="line">      sum += pow(useritems[u1][item] - useritems[u2][item] , <span class="number">2</span>)</span><br><span class="line">      </span><br><span class="line">similarity = sqrt(sum)</span><br></pre></td></tr></table></figure><h3 id="皮尔逊相关度评价"><a href="#皮尔逊相关度评价" class="headerlink" title="皮尔逊相关度评价"></a>皮尔逊相关度评价</h3><p>皮尔逊相关系数是判断两组数据与某一直线拟合程度的一种度量（即尽可能使图中红线靠近所有坐标点）</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fkzh47nzf3j309n08e3yh.jpg" alt=""></p><p>皮尔逊相关度计算函数会返回介于-1与1之间的数据。当值为1时表明两个人对每一个物品是完全一致的评价，值为-1时则表明两者完全不相关</p><h2 id="推荐物品"><a href="#推荐物品" class="headerlink" title="推荐物品"></a>推荐物品</h2><p>为所有用户和待推荐用户计算相似度，根据相似度进行排名；这里我们得到了品味相近的人，现在想获得物品的推荐，当然我们可以从品味相近的用户中挑选尚未评价过的物品，但这样太随意了，可能存在的问题：</p><ol><li>品味相近的用户尚未对某个物品进行评价，可能这个物品是想要的</li><li>品味相近的用户不看好某个物品，但可能这个物品是想要的</li></ol><p>为了解决上述问题，我们需要通过一个加权的用户评价值表来进行打分</p><p>用户1的加权用户评价值表：</p><div class="table-container"><table><thead><tr><th></th><th>相似度</th><th>物品1</th><th>S(物品1)</th><th>物品2</th><th>S(物品2)</th><th>物品n</th><th>S(物品n )</th></tr></thead><tbody><tr><td>用户2</td><td>0.38</td><td>3</td><td>物品1 * 相似度</td><td>3</td><td></td><td></td><td></td></tr><tr><td>用户3</td><td>0.89</td><td></td><td></td><td>4</td><td></td><td>4.5</td><td></td></tr><tr><td>用户4</td><td>0.92</td><td>4</td><td></td><td>4</td><td></td><td></td><td></td></tr><tr><td>用户5</td><td>0.66</td><td>4</td><td></td><td>4</td><td></td><td>4.5</td><td></td></tr><tr><td>总计</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Sim.Sum</td><td></td><td></td><td>相似度之和(该用户所有评论的物品)</td><td></td><td></td><td></td><td></td></tr><tr><td>总计/Sim.Sum</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>总计：得到用户对物品的评价，品味相近的人，为评价值提供更多的贡献</p><p>总计/Sim.Sum：为了防止受更多人评论的物品影响最终评价结果，需要用总计值/相似度之和进行标准化</p><p>最终我们会得到用户对所有物品的评价值列表，经过按评价值排序后，最后输出推荐列表</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>对于用户和物品数量级很大的情况，将一个用户和所有其他用户进行比较，然后再对每位用户评过分的商品进行比较，其速度是难以忍受的</p><p>并且也许用户在偏好方面在彼此间很少会有重叠，这可能会令计算用户的相似度判断变得十分困难</p><h1 id="基于物品推荐"><a href="#基于物品推荐" class="headerlink" title="基于物品推荐"></a>基于物品推荐</h1><p>基于物品的协作型过滤允许我们将大量的计算任务预先执行，从而使需要给予推荐的用户能够更快地得到他们想要的结果</p><p>总体思路：</p><ol><li>为每件物品预先计算好最为相近的物品</li><li>推荐时，取到该用户评价过的所有物品，找到与这些物品相似的物品</li><li>根据计算相似度加权后输出评价值</li></ol><p>与基于用户推荐的区别是：物品间的比较不会像用户间比较的那么频繁变化，这就意味着这个计算过程可以离线进行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐的一些基本介绍&lt;/p&gt;
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.ziwenzou.com/categories/machine-learning/"/>
    
    
      <category term="recommendation" scheme="http://blog.ziwenzou.com/tags/recommendation/"/>
    
  </entry>
  
  <entry>
    <title>Git系列之基础篇--push、pull、fetch</title>
    <link href="http://blog.ziwenzou.com/2017/05/09/2017-05-09-git_05/"/>
    <id>http://blog.ziwenzou.com/2017/05/09/2017-05-09-git_05/</id>
    <published>2017-05-08T16:00:00.000Z</published>
    <updated>2017-11-11T14:57:26.673Z</updated>
    
    <content type="html"><![CDATA[<p>《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过<code>add</code>和<code>commit</code>命令使我们能将更改应用到Git本地仓库，但Git作为分布式版本控制系统，还存在一个分布式远程仓库，本地仓库只是远程仓库的一个副本。本篇将通过push、pull、fetch等命令让大家了解如何和Git远程仓库交互。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><blockquote><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库，本地仓库中可同时存在一个或多个远程仓库</p></blockquote><p>在<a href="/2017-05-05/git_02">Git系列—Git仓库</a>文章中也有提到远程仓库的概念，并且提到了remote命令—用于管理远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  mastery001.github.io git:(develop) ✗ git remote -v</span><br><span class="line">originhttps://github.com/mastery001/mastery001.github.io.git (fetch)</span><br><span class="line">originhttps://github.com/mastery001/mastery001.github.io.git (push)</span><br></pre></td></tr></table></figure><p>通过<code>git remote -v</code>命令可列出当前仓库的远程仓库地址和alias，这里我们的本地仓库中有一个远程仓库了，下面我们就详细介绍如何将本地更新提交至远程或从远程同步等操作</p><h1 id="push"><a href="#push" class="headerlink" title="push"></a>push</h1><p>语法为<code>git push remote_alias branch_name</code></p><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>语法为<code>git fetch remote_alias branch_name</code></p><h1 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h1><p>语法为<code>git pull remote_alias branch_name</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git系列之基础篇--commit</title>
    <link href="http://blog.ziwenzou.com/2017/05/08/2017-05-08-git_04/"/>
    <id>http://blog.ziwenzou.com/2017/05/08/2017-05-08-git_04/</id>
    <published>2017-05-07T16:00:00.000Z</published>
    <updated>2017-11-11T14:57:32.434Z</updated>
    
    <content type="html"><![CDATA[<p>《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前一节介绍了<code>add</code>命令—将当前工作目录的修改添加至暂存区，那么存储至暂存区后应当及时交由Git数据库进行版本管理，这时就是此篇文章需要介绍的<code>commit</code>命令大展身手的时候了！</p><h1 id="commit提交"><a href="#commit提交" class="headerlink" title="commit提交"></a>commit提交</h1><blockquote><p><code>commit</code>顾名思义为提交，其作用是将暂存区的内容提交至Git本地数据库，注意，每次提交都仅作用于当前<a href="">分支</a></p></blockquote><p>1.语法</p><p><code>git commit [options] ...</code>（更多参数详见：<a href="https://git-scm.com/docs/git-commit" target="_blank" rel="external">git-commit</a>）</p><p>2.提交内容</p><p>git进行提交操作时会保存一个提交对象，包含如下内容：</p><ul><li>指向暂存内容快照的指针(暂存操作会为每一个文件使用SHA-1 哈希算法计算校验和，生成一个blob对象)</li><li>作者的姓名和邮箱</li><li>提交时输入的信息以及指向它的父对象的指针（首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象）</li></ul><h2 id="初级使用"><a href="#初级使用" class="headerlink" title="初级使用"></a>初级使用</h2><p>使用<code>add</code>命令我们已经将当前工作目录所有的修改都已经添加进暂存区了(可用<code>git status确认是否已经添加进暂存区</code>)，之后运行提交命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ✗ git commit -m &quot;first commit&quot;</span><br><span class="line">[master (root-commit) 6fffa3a] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">➜  test git:(master) git log</span><br><span class="line">commit 6fffa3a925f1454195a297c7b5373c273eeaa5aa</span><br><span class="line">Author: zouziwen &lt;zouziwen@meituan.com&gt;</span><br><span class="line">Date:   Mon May 8 17:35:28 2017 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>从commit执行后返回的信息可得出本次提交时在master分支，commit-id为6fffa3a，commit-message为first commit，一个文件被插入；并且如上例，可通过<a href="#git-log">git log</a>来查询当前工作目录的提交历史</p><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><p>与<code>add</code>命令相同，Git也提供了一组高级命令来完成完成<code>commit</code>操作，在前一节<code>add</code>高级命令的基础上向下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) git write-tree// 在当前目录生成树</span><br><span class="line">9d223a574a4b40a55bbf02a047c042c6c0b889a9</span><br><span class="line">➜  test git:(master) echo &quot;first commit&quot; | git commit-tree 9d223a574a4b40a55bbf02a047c042c6c0b889a9   // 提交tree</span><br><span class="line">85f186d00fe88ab272053dfe0d80b1f26dec6464</span><br><span class="line">➜  test git:(master) git update-ref refs/heads/master 85f186d00fe88ab272053dfe0d80b1f26dec6464  //更新当前分支的commit</span><br><span class="line">➜  test git:(master) git log </span><br><span class="line">commit 85f186d00fe88ab272053dfe0d80b1f26dec6464</span><br><span class="line">Author: zouziwen &lt;zouziwen@meituan.com&gt;</span><br><span class="line">Date:   Mon May 8 18:33:45 2017 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><h3 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) git cat-file -t cb19826acbc17d65e6b492abf2b5b10930c184f3</span><br><span class="line">blob</span><br><span class="line">➜  test git:(master) git cat-file -t 9d223a574a4b40a55bbf02a047c042c6c0b889a9</span><br><span class="line">tree</span><br><span class="line">➜  test git:(master) git cat-file -t 85f186d00fe88ab272053dfe0d80b1f26dec6464</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><p>如上命令分别得出Git对象存储的内容，如下图：</p><p><img src="/images/git/commiter.png" alt="Git对象"></p><p>Git会为每个文件都生成一个数据对象(blob-object)，而为了解决文件名保存的问题，还提供了一个树对象(tree-object)。Git以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><p>Git会为每次commit生成一个commit对象，每个commit对象对应一个tree，而此tree对象相当于当前目录根目录；</p><p><img src="/images/git/master_tree.png" alt="根目录的所有对象"></p><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p><code>git log</code>命令输出了当前工作分支的提交历史，默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p>至于使用在官网文档中介绍的很清楚，这里就不多余举出。传送门：<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="external">git-log</a></p><p>上一篇：<a href="/2017-05-06/git_03">Git系列之基础篇—add</a></p><p>下一篇：<a href="/2017-05-09/git_05">Git系列之基础篇—push、pull、fetch</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git系列之基础篇--add</title>
    <link href="http://blog.ziwenzou.com/2017/05/06/2017-05-06-git_03/"/>
    <id>http://blog.ziwenzou.com/2017/05/06/2017-05-06-git_03/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2017-11-11T14:57:56.505Z</updated>
    
    <content type="html"><![CDATA[<p>《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前两篇分别介绍Git版本控制系统和Git仓库的一些知识，从本章起将正式深入Git的使用；</p><p>在第一篇文章<a href="/2017-05-04/git_01">《Git系列—初识》</a>中提到了文件状态的几种类型，除了<code>已提交</code>状态之外，Git工作目录下不外乎就两种文件状态：已跟踪或未跟踪。 </p><ol><li>已跟踪：是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</li><li>未跟踪：工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 </li></ol><p><img src="/images/git/lifecycle.png" alt="文件的状态变化周期"></p><p>从上图中可以看出无论是Untracked或Modified状态的文件最终都需要转换成Staged状态的文件才能被Git管理，一般称Staged状态的文件为存入暂存区的文件。</p><h1 id="status"><a href="#status" class="headerlink" title="status"></a>status</h1><p>在正式使用<code>add</code>命令之前，在这里先引入<code>status</code>命令，其作用为检查当前文件状态；一般的，Git工作目录下的文件除上述介绍的几种文件状态之外，还有一种特殊的状态，即未更改状态—代表所有已跟踪文件在上次提交后都未被更改过。</p><p>语法为：<code>git status</code></p><h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><p><code>add</code>命令在Git版本控制中其含义是将所有Untracked和Unstaged的文件放入暂存区，暂存区的文件即可被Git跟踪管理的文件。</p><h2 id="初级使用"><a href="#初级使用" class="headerlink" title="初级使用"></a>初级使用</h2><p>一般的，使用<code>git add</code>命令开始追踪一个文件，其语法为：<code>git add [&lt;options&gt;] [--] &lt;pathspec&gt;...</code>(options可通过<code>git add -h</code>查看，亦可查阅<a href="https://git-scm.com/docs/git-add" target="_blank" rel="external">add</a>)</p><p>所以如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ✗ echo &quot;test&quot; &gt; test.txt</span><br><span class="line">➜  test git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">test.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">➜  test git:(master) ✗ git add test.txt   (亦可为 git add . 为添加当前目录所有未跟踪或未暂存文件)</span><br><span class="line">➜  test git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   test.txt</span><br></pre></td></tr></table></figure><p>上述实例中当创建一个新文件<code>test.txt</code>时，使用<code>git status</code>命令查看，Git会提示<code>Untracked files:(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</code>；而当执行add操作后，会提示<code>Changes to be committed:(use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</code>，可使用<code>git rm --cached</code>命令将该文件移除暂存区；所以读者可勤用<code>git status</code>命令，Git会友好的提示一些命令。</p><p>再次修改文件test.txt使用<code>git status</code>查看发现修改已暂存的文件出现modified状态的文件，根据<code>git status</code>提示，若需要应用此次修改则使用<code>git add</code>，若不应用则使用<code>git checkout --</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ✗ echo &quot;test11&quot; &gt; test.txt</span><br><span class="line">➜  test git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   test.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   test.txt</span><br><span class="line">➜  test git:(master) ✗ git add .</span><br><span class="line">➜  test git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   test.txt</span><br></pre></td></tr></table></figure><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><p>前文中使用<code>git add</code>命令可将文件放入暂存区进行追踪，那么Git还提供了一套高级命令来完成<code>git add</code>操作；</p><p>Git是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-value data store）。它会为每一个暂存区的文件使用SHA-1 哈希算法计算校验和，生成一个blob对象。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 可以通过底层命令 hash-object 来演示上述效果——该命令可将任意数据保存于 .git 目录，并返回相应的键值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ✗ ls</span><br><span class="line">test.txt</span><br><span class="line">➜  test git:(master) ✗ git hash-object -w test.txt</span><br><span class="line">cb19826acbc17d65e6b492abf2b5b10930c184f3</span><br><span class="line">➜  test git:(master) ✗  git cat-file -p cb19826acbc17d65e6b492abf2b5b10930c184f3</span><br><span class="line">test11</span><br><span class="line">➜  test git:(master) ✗ git cat-file -t cb19826acbc17d65e6b492abf2b5b10930c184f3</span><br><span class="line">blob</span><br><span class="line">➜  test git:(master) ✗ git update-index --add --cacheinfo 100644 cb19826acbc17d65e6b492abf2b5b10930c184f3 test.txt</span><br><span class="line">➜  test git:(master) ✗ git st</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   test.txt</span><br></pre></td></tr></table></figure><ol><li>git hash-object -w 数据来源(stdin或文件) :<br>输出长度为 40 个字符的校验和(一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和)</li><li>git cat-file -p SHA-1  :<br>输出校验值对应的内容，-p是判断其值并显示其内容 , -t为输出该hash的类型，取值有blob,tree,commit</li><li>git update-index —add —cacheinfo 文件模式 SHA-1 文件名 :<br>必须为上述命令指定 —add 选项，因为此前该文件并不在暂存区中;同样必需的还有 —cacheinfo 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。<br>文件模式：<ul><li>100644：普通文件</li><li>100755：可执行文件</li><li>120000：符号链接</li><li>三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</li></ul></li></ol><p>此时可查看.git目录下的objects内容（根据SHA-1的hash值存储的文件）：</p><p><img src="/images/git/hash-object.png" alt="objects内容为"></p><p>从上述的实例中我们再次能感受到Git其内部原理是键值对数据库（key-value data store），通过文件的hash值来定位文件的修改。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p><code>git add</code>命令是将未暂存的文件存入暂存区，其内部原理是计算出该文件对应的hash值，并存储至objects目录下，以通过其内容来管理变更。</p></blockquote><h1 id="SHA-1-哈希算法"><a href="#SHA-1-哈希算法" class="headerlink" title="SHA-1 哈希算法"></a>SHA-1 哈希算法</h1><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<br>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。</p><p>上一篇：<a href="/2017-05-05/git_02">Git系列—Git仓库</a></p><p>下一篇：<a href="/2017-05-08/git_04">Git系列之基础篇—commit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git系列--Git仓库</title>
    <link href="http://blog.ziwenzou.com/2017/05/05/2017-05-05-git_02/"/>
    <id>http://blog.ziwenzou.com/2017/05/05/2017-05-05-git_02/</id>
    <published>2017-05-04T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:00.442Z</updated>
    
    <content type="html"><![CDATA[<p>《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>前一篇文章中简单引入了Git仓库的概念—用来保存项目的元数据和对象数据库的地方，是整个Git数据库的集合；</p></blockquote><p>Git仓库是整个Git版本控制系统的基础，所有的Git操作都必须基于Git仓库，下面就让我们来认识一下它吧！</p><h1 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h1><p>Git项目仓库的获取方式有以下两种：</p><ol><li>本地创建Git仓库</li><li>从Git远程服务器克隆仓库</li></ol><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>本地创建Git仓库的方式可以用一条命令来完成：</p><ol><li>cd到需要项目目录中</li><li>执行<code>git init</code>操作初始化仓库</li></ol><p><img src="/images/git/init.png" alt=""></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果你正在进行团队协作项目开发或更换电脑需要重新拉取项目，那么<code>git clone</code>能很好的帮你从远程拉取到远程Git仓库中最新版本的项目代码；</p><p>克隆仓库的命令格式是<code>git clone [url]</code>，当然你也可以拉取Git仓库中特定分支的内容，格式是<code>git clone -b [branch] [url]</code></p><p><img src="/images/git/clone.png" alt=""></p><p><code>git clone</code>命令默认拉取的是远程Git仓库master分支中的数据，默认配置中会拉取每一个文件的每一个版本</p><h2 id="Git仓库目录结构"><a href="#Git仓库目录结构" class="headerlink" title="Git仓库目录结构"></a>Git仓库目录结构</h2><p>一个新的Git仓库的目录结构如下图所示：</p><p><img src="/images/git/git_dir.png" alt=""></p><ul><li>HEAD:指示目前被检出的分支</li><li>config:包含项目特有的配置选项</li><li>description:仅供 GitWeb 程序使用，我们无需关心</li><li>hooks:包含客户端或服务端的钩子脚本（hook scripts）</li><li>info:包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</li><li>objects:存储所有数据内容</li><li>refs:存储指向数据（分支）的提交对象的指针</li></ul><h1 id="配置与使用"><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h1><blockquote><p>这部分的内容主要介绍了一些Git正式使用前的一些准备工作和简单使用，config和remote两个指令。</p></blockquote><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>在使用Git之前需要配置姓名和邮箱等信息(不配置该信息可能无法提交至远程)，那么配置的方式有以下两种：</p><ol><li><code>git config</code>指令</li><li>文件配置</li></ol><p>(1)指令方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p><code>--global</code>选项的含义代表全局配置，即只要配置一次即可在当前机器上生效，若需要对某个项目单独配置，需在该项目目录下执行config命令，但不必带上<code>--global</code>参数。</p><p>config全部可选参数可见官网文档：<a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">git-config</a></p><p>(2)文件方式</p><ol><li>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 —system 选项的 git config 时，它会从此文件读写配置变量。</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 —global 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。</li></ol><p>上述三个文件对应的作用域级别不同，顺序为 仓库级别 &gt; 用户级别 &gt; 系统级别</p><p>补充：可通过<code>config</code>命令来查看已生效的配置：<code>git config --list</code></p><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>Git作为分布式版本控制系统的代表，其主要作用是为了能更好的进行团队协作，故进行远程Git仓库的配置是必不可少的；</p><p><code>git remote -v</code>可查看当前Git仓库关联的远程库列表(通过<code>git clone</code>的仓库自动带有远程仓库的信息)，附上博主的一个Git仓库</p><p><img src="/images/git/remote.png" alt=""></p><p>左侧的origin为远程仓库的别名，右侧为远程Git仓库的地址</p><p>remote的一些简单操作：</p><ol><li>若是本地创建的Git仓库，则需要手动添加远程Git仓库：<code>git remote add [alias] [url]</code></li><li>重命名：<code>git remote rename [old_alias] [new_alias]</code></li><li>删除远程仓库：<code>git remote rm [alias]</code></li></ol><p>上一篇：<a href="/2017-05-04/git_01">Git系列—初识</a></p><p>下一篇：<a href="/2017-05-06/git_03">Git系列之基础篇—add</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git系列--初识</title>
    <link href="http://blog.ziwenzou.com/2017/05/04/2017-05-04-git_01/"/>
    <id>http://blog.ziwenzou.com/2017/05/04/2017-05-04-git_01/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:03.974Z</updated>
    
    <content type="html"><![CDATA[<p>《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理<br><a id="more"></a></p><h1 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h1><p>博主在读大学初期未曾接触过版本控制系统，在这里分享一下博主最初的手工版本控制</p><ol><li>写新功能的代码先保存一份当前工程代码的副本project_01</li><li>在当前工程代码的基础上进行开发，开发完毕后突然发现尚可有更好的实现方式，但又想保存此次实现（以便参考），于是保存项目副本project_02</li><li>完成第二步后，将project_01重新导入编辑器，重新开发</li></ol><p>见下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                  (开发)</span><br><span class="line">project_01 ----&gt; project_02</span><br><span class="line">          \</span><br><span class="line">           \ (重新导入project_01开发)</span><br><span class="line">             ----&gt; project03</span><br></pre></td></tr></table></figure><p>上述手工版本控制的缺点：</p><ol><li>不便于比较，需要手动定位至文件目录下</li><li>开发项目麻烦，导入和删除步骤繁琐</li></ol><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><blockquote><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p></blockquote><h2 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h2><p>最初版本控制系统也是和博主的方式一样进行手工操作，后来为了解决手工的问题，人们用数据库来记录文件历次更新的差异。如下图（代表的有RCS）</p><p><img src="/images/git/local_vcs.png" alt=""></p><h2 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h2><p>本地版本控制系统对于个人用户来说是绰绰有余的，但对于企业用户来说却并不适应，于是乎就出现了<code>CVS</code>、<code>Subversion</code>以及<code>Perforce</code>等集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）,</p><p><img src="/images/git/cvcs.png" alt=""></p><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>集中化的版本控制系统存在一个致命的缺陷—单点故障，分布式版本控制系统（Distributed Version Control System，简称 DVCS）的代表有：<code>Git</code>、<code>Mercurial</code>、<code>Bazaar</code> 以及 <code>Darcs</code> 等</p><p><img src="/images/git/dvcs.png" alt=""></p><h2 id="差异性"><a href="#差异性" class="headerlink" title="差异性"></a>差异性</h2><div class="table-container"><table><thead><tr><th>版本控制系统</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>本地版本控制系统</td><td>持久化，防丢失</td><td>不利于团队协作</td></tr><tr><td>集中化的版本控制系统</td><td>团队协作，权限分明</td><td>中央服务器的单点问题</td></tr><tr><td>分布式版本控制系统</td><td>分布式，持久化，团队协作，clone即备份</td><td>项目大的情况下提取慢</td></tr></tbody></table></div><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git是分布式版本控制系统的一种，其特点在于：</p><ol><li>大部分版本控制系统以保存文件变更列表来存储信息，而git则是采用将变更的整个文件进行保存快照方式存储</li><li>Git是本地可以完成所有操作，直至版本上线时才需要将提交push至远程</li><li>为了保证完整性，git会在文件存储前计算校验和，之后通过校验和引用</li></ol><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>一个Git的版本控制中文件存在四种状态：</p><ol><li>Untracked(未追踪文件)：尚未添加至版本控制中的文件</li><li>staged(已暂存)：添加至暂存区的文件(git add )</li><li>modified(已修改)：在现有版本上进行修改的文件</li><li>committed(已提交)：提交至本地数据库中的文件（git commit）</li></ol><h2 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h2><p>Git存在三个工作区域的概念：</p><ol><li>Git仓库：用来保存项目的元数据和对象数据库的地方，是整个git数据库的集合</li><li>工作目录：对项目的某个版本提取出来的内容，即工作分支</li><li>暂存区：也称为索引，保存了下次将要提交的信息</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>一个完整的git工作流程如下：</p><ol><li>建立或克隆一个Git仓库，并将其或者在其基础上创建工作目录</li><li>在工作目录中添加或修改文件</li><li>将文件的修改添加至暂存区中</li><li>提交更新，将Git暂存区中的文件commit至Git仓库中</li><li>push至远程</li></ol><p>下一篇：<a href="/2017-05-05/git_02">Git系列—Git仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Git系列》文章是博主阅读Git官方book提取整理出的内容，意在深入理解Git的工作机制、原理&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Codis线上加密码</title>
    <link href="http://blog.ziwenzou.com/2017/03/01/2017-03-01-codis_hot_set_password/"/>
    <id>http://blog.ziwenzou.com/2017/03/01/2017-03-01-codis_hot_set_password/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:10.424Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客为codis的集群使用者提供线上加密码的方法，并且详解了其每一步操作，绝对干货！<br><a id="more"></a></p><h1 id="线上告警"><a href="#线上告警" class="headerlink" title="线上告警"></a>线上告警</h1><p>前面一篇博客已经简单介绍了Codis是什么，具体可跳转：<a href="/2016-09-22/codis_introduction/">Codis初体验心得</a></p><p>前几日，博主部署的Codis集群的一个group中的master的<code>Mem Used</code>显示为<code>/NaN GB</code>，<br><img src="/images/codis/mem_used.png" alt="Mem Used"><br>导致Codis集群无法正常提供服务，日志如下：<br><img src="/images/codis/error_log.png" alt="error log"></p><p>查看该端口的日志发现，</p><ol><li>连接zk时出现<code>request time out</code>提示错误，</li><li>并且在<code>top</code>中发现有一个进程占了<code>778.7%</code>CPU</li></ol><p><img src="/images/codis/virus.png" alt="virus"></p><p>后通过运维了解到，由于redis未设置密码，并且redis存在公网ip，导致黑客通过redis的该漏洞植入了木马程序，导致该端口不能正常提供服务；同样的在网上找到了redis该漏洞的描述：<a href="http://blog.jobbole.com/94518/" target="_blank" rel="external">Redis 未授权访问缺陷可轻易导致系统被黑</a></p><p>解决方案：</p><ol><li>屏蔽公网ip</li><li>给codis集群设置密码</li><li>重新搭建集群，并将数据重新导入(<code>适用于集群中未做过migrate操作</code>)</li></ol><p>当然这里博主采用的是第二种方案。</p><h1 id="Codis加密"><a href="#Codis加密" class="headerlink" title="Codis加密"></a>Codis加密</h1><p><strong>Notes</strong>：Codis加密的过程中由于要重启代理，所以会导致服务无法正常提供服务；</p><p>加密步骤：</p><ol><li>在config.ini添加password选项</li><li>修改每个codis-server的密码</li><li>重启proxy和dashboard</li><li>线上服务添加密码并重启</li></ol><p>例如本次需要为codis添加密码为<code>123456</code>,下面就详细介绍每一步.</p><h2 id="修改config-ini"><a href="#修改config-ini" class="headerlink" title="修改config.ini"></a>修改config.ini</h2><p>在config.ini文件中添加password选项，如下图：<br><img src="/images/codis/config.png" alt="config"></p><h2 id="修改codis-server"><a href="#修改codis-server" class="headerlink" title="修改codis-server"></a>修改codis-server</h2><p>每一个codis-server相当于redis服务，所以改其密码可使用与redis方式一致，可参考：<a href="http://blog.csdn.net/zyz511919766/article/details/42268219" target="_blank" rel="external">redis配置认证密码</a></p><p>连接每一个codis-server后执行：<code>config set requirepass 123456</code></p><p>当然，最好要将对应的redis.conf文件中的requirepass密码也加上哦，这样能保证配置文件与运行的服务一致；</p><h2 id="重启proxy和dashboard"><a href="#重启proxy和dashboard" class="headerlink" title="重启proxy和dashboard"></a>重启proxy和dashboard</h2><p>在描述重启的操作之前先在这引入下<code>kill</code>这个指令的作用，这里引用下其描述信息，具体可参考:<a href="http://man.linuxde.net/kill" target="_blank" rel="external">kill命令</a></p><blockquote><p>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。</p></blockquote><p>通过上面一句话我们可以了解到，kill默认可发送一个信号至程序，预示该程序须终止；那么就意味着当我们调用kill命令关闭codis的程序时，意味着通知zk要移除该codis程序；</p><p>所以重启proxy和dashboard如下：</p><ul><li>获取到proxy和dashboard的进程id</li><li>调用kill 进程id 通知zk移除proxy和dashboard</li><li>启动proxy和dashboard；<ol><li>proxy：<code>nohup ../bin/codis-proxy --log-level info -c config.ini -L ./log/proxy.log  --cpu=8 --addr=0.0.0.0:19000 --http-addr=0.0.0.0:11000 &amp;</code></li><li>dashboard：<code>nohup ../bin/codis-config -c config.ini -L ./log/dashboard.log dashboard --addr=:18087 --http-log=./log/requests.log &amp;&gt;/dev/null &amp;</code></li></ol></li></ul><h2 id="线上服务添加密码"><a href="#线上服务添加密码" class="headerlink" title="线上服务添加密码"></a>线上服务添加密码</h2><p>具体添加密码的方式与redis添加密码方式无异，不过博主这里使用的是经过博主完善的<a href="https://github.com/mastery001/codis-spring-java" target="_blank" rel="external">codis-spring-java</a>,其基于codis作者提供的<a href="https://github.com/reborndb/reborn-java" target="_blank" rel="external">Reborn-java</a>添加了如下功能：</p><ol><li>适配Spring-data-redis</li><li>当zk连接状态变化时，判断是否CONNECTED或RECONNECTED，若是则重新加载pools</li><li>添加password选项</li></ol><p>执行完上述步骤后即可上线重启服务.</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>在本次事故中发现Codis集群在master无法正常提供服务时，slave不会自动切换为master，这是一大缺陷.</p><p>后面在网上查阅资料发现有第三方服务<a href="https://github.com/ngaut/codis-ha" target="_blank" rel="external">codis-ha</a>，不过貌似其不支持auth，即当codis集群存在密码时会导致主从连接丢失：<a href="https://github.com/CodisLabs/codis/issues/350" target="_blank" rel="external">dashboard引入codis-ha的功能</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.jobbole.com/94518/" target="_blank" rel="external">Redis 未授权访问缺陷可轻易导致系统被黑</a></li><li><a href="http://blog.csdn.net/zyz511919766/article/details/42268219" target="_blank" rel="external">redis配置认证密码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客为codis的集群使用者提供线上加密码的方法，并且详解了其每一步操作，绝对干货！&lt;br&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://blog.ziwenzou.com/categories/Knowledge/"/>
    
    
      <category term="cache" scheme="http://blog.ziwenzou.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO类概述</title>
    <link href="http://blog.ziwenzou.com/2017/02/22/2017-02-22-java_nio/"/>
    <id>http://blog.ziwenzou.com/2017/02/22/2017-02-22-java_nio/</id>
    <published>2017-02-21T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:18.942Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客的初衷是记录了博主本次阅读系列博客(Java NIO入门教程详解—链接见文末)全文过程中的一些笔记，描述了Java NIO中核心类以及其方法的作用；</p><a id="more"></a><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p><img src="/images/java_nio/buffer.png" alt="Buffer继承图"></p><p>1.属性</p><ul><li><code>capacity</code>：容量</li><li><code>limit</code>：上界，缓冲区的临界区，即最多可读到哪个位置</li><li><code>position</code>：下标，当前读取到的位置(例如当前读出第5个元素，则读完后，position为6)</li><li><code>mark</code>：标记，备忘位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大小关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</span><br></pre></td></tr></table></figure><p>2.方法</p><ul><li><code>mark()</code>：记录当前position的位置，使<code>mark=position</code></li><li><code>reset()</code>：恢复到上次备忘的位置，即<code>position=mark</code></li><li><code>clear()</code>：将缓存区置为待填充状态，即<code>position=0;limit=capacity;mark=-1</code></li><li><code>flip()</code>：将缓冲区的内容切换为待读取状态，即<code>limit=position;position=0;mark=-1</code></li><li><code>rewind()</code>：恢复缓冲区为待读取状态，即<code>position=0;mark=-1</code></li><li><code>remaining()</code>：缓冲区剩余元素，即<code>limit-position</code></li><li><code>compact()</code>：丢弃已经读取的数据，保留未读取的数据，并使缓存中处于待填充状态</li><li><code>isDirect()</code>：是否是直接操作内存的Buffer；若是，则此Buffer直接操作JVM堆外内存 ，使用Unsafe实现；否则操作JVM堆内存</li><li><code>slice()</code>：从当前buffer中生成一个该buffer尚未使用部分的新的缓冲区，例如当前buffer的position为3，limit为5，则新的缓冲区limit和capacity都为2，offset的3，数据区域两者共享；</li></ul><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><blockquote><p>简单的说，Channel即通道，JDK1.4新引入的NIO概念，一种全新的、极好的Java I/O示例，提供与I/O服务的直接连接。Channel用于在字节缓存和位于Channel另一侧的实体(通常是File或Socket)之间有效的传输数据。<br>通道(Channel)是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。缓冲区(Buffer)则是通道内部用来发送和接受消息的端点。</p></blockquote><p><img src="/images/java_nio/channel.png" alt="Channel继承图"></p><p>1.方法</p><ul><li><code>close()</code>：调用close方法会导致工作在该通道上的线程暂时阻塞；close关闭期间，任何其他调用close方法的线程将会阻塞；如果一个线程工作在该通道上被阻塞并且同时被中断，那么该通道将会关闭</li><li><code>isOpen()</code>：通道的开关状态</li></ul><p>2.Scatter/Gather</p><p><a href="http://www.365mini.com/page/java-nio-course-17.htm" target="_blank" rel="external">Scatter/Gather</a>允许您委托操作系统来完成辛苦活：将读取到的数据分开存放到多个存储桶(bucket)或者将不同的数据区块合并成一个整体。这是一个巨大的成就，因为操作系统已经被高度优化来完成此类工作了。它节省了您来回移动数据的工作，也就避免了缓冲区拷贝和减少了您需要编写、调试的代码数量。</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><blockquote><p><a href="http://www.365mini.com/page/java-nio-course-18.htm" target="_blank" rel="external">FileChannel</a>是线程安全的，只能通过FileInputStream,FileOutputStream,RandomAccessFile的getChannel方法获取FileChannel通道，原理是获取到底层操作系统生成的fd(file descriptor)</p></blockquote><p>1.方法</p><ul><li>FileChannel的position属于共享的，属于底层fd的position，当调用RandomAccessFile的<code>seek()</code>方法调整position，则生成的FileChannel对象的position为seek后的值</li><li><code>truncate()</code>：用于设置文件的长度size，若设置的size&lt;当前size，则多出的部分会被删除</li><li><code>force()</code>：强制将全部待定的修改都写入磁盘中的文件上(所有的现代文件系统都会缓存数据和延迟磁盘文件更新以提高性能)【<strong>若是force作用于远程文件系统，则不能保证该操作一定能成功，需要验证当前使用的操作系统或文件系统在同步修改方面是否可以依赖</strong>】</li><li><code>transferTo()</code>和<code>transferFrom()</code>：允许将一个通道交叉连接到另一个通道传递数据；</li></ul><h3 id="文件锁（FileLock）"><a href="#文件锁（FileLock）" class="headerlink" title="文件锁（FileLock）"></a>文件锁（FileLock）</h3><ul><li>文件锁的对象是文件而不是通道或线程；</li><li>获得独占锁的前提是对文件有写权限，获得共享锁只要对文件有读权限即可</li><li>如果一个线程在一个文件上获得了独占锁，若运行在同一JVM上，则另一个线程请求文件的独占锁是允许的；若运行在不同的JVM上，则其线程请求文件的独占锁会被阻塞；因为锁最终是由操作系统或文件系统来判优并且几乎总是在进程级别而不是在线程级别上判优</li><li>独占锁和共享锁是由底层操作系统或文件系统决定，若底层不支持共享锁，则即使获取锁时的shared参数为true，调用FileLock的<code>isShared()</code>方法也将返回false</li><li><p>FileLock从获取到之后有效，失效条件：</p><ol><li>调用FileLock中的<code>release()</code>方法</li><li>它所关联的通道被关闭</li><li>JVM关闭</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是FileChannel关于FileLock的API（抛出IOException，这里未列出）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件的独占锁（获取操作是阻塞的），等价于调用lock(0,Long.MAX_VALUE , false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//指定文件内部锁定区域的开始position以及锁定区域的size，shared标识待获取是共享锁(true)还是独占锁(false)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 文件锁的范围可以大于文件的大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// lock方法的非阻塞方式，若是待获取的区域是已经被锁定的，则此时会直接返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span> <span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br></pre></td></tr></table></figure><h3 id="内存文件映射"><a href="#内存文件映射" class="headerlink" title="内存文件映射"></a>内存文件映射</h3><blockquote><p>内存文件映射，简单地说就是将文件映射到内存的某个地址上。&gt;1. 普通方式读取文件流程<br>首先内存空间分为内核空间和用户空间，在应用程序读取文件时，底层会发起系统调用，由系统调用将数据先读入到内核空间，然后再将数据拷贝到应用程序的用户空间供应用程序使用。这个过程多了一个从内核空间到用户空间拷贝的过程。&gt;2. 内存文件映射流程文件会被映射到物理内存的某个地址上（不是数据加载到内存），此时应用程序读取文件的地址就是一个内存地址，而这个内存地址会被映射到了前面说到的物理内存的地址上。应用程序发起读之后，如果数据没有加载，系统调用就会负责把数据从文件加载到这块物理地址。应用程序便可以读取到文件的数据。省去了数据从内核空间到用户空间的拷贝过程。所以速度上也会有所提高。</p></blockquote><p>在Java中，具体内存文件映射的方法是<strong>通过FileChannel的map()方法来创建一个由磁盘文件支持的虚拟文件映射(virtual memory mapping)并在那块虚拟内存空间外部封装一个MappingByteBuffer对象</strong></p><ul><li>通过内存映射机制来访问一个文件效率比其他方式高，因为不需要做明确的系统调用；其直接操作的内存使位于JVM堆外的内存，且虚拟内存可以自动缓存内存页(memory page)</li><li>当为一个文件建立虚拟内   存映射之后，文件数据通常不会因此被从磁盘读取到内存(这取决于操作系统)。该过程类似打开一个文件：文件先被定位，然后一个文件句柄会被创建，当您准备好之后就可以通过这个句柄来访问文件数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二、三个参数分别表示映射区域的开始(position)和映射的总大小(size)</span></span><br><span class="line"><span class="comment">// 若map的size&gt;文件的大小，则文件会自动扩容至size</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,<span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MapMode的三种模式，受FileChannel的访问权限控制</span></span><br><span class="line"><span class="function">1. READ_ONLY：只读权限</span></span><br><span class="line"><span class="function">2. READ_WRITE：写权限</span></span><br><span class="line"><span class="function">3. PRIVATE：写时拷贝<span class="params">(copy-on-write)</span>映射；意味着通过`<span class="title">put</span><span class="params">()</span>`方法所做的任何修改都会导致产生一个对原数据的私有的数据拷贝，之后将修改应用到拷贝后的数据，此份数据只能被当前MappedByteBuffer对象所见</span>;（**Notes：PRIVATE的拷贝是按内存页拷贝的，若一次put操作只修改了前一个内存页的内容，则后一个内存页的被READ_WRITE的修改也会应用到PRIVATE的映射中**）</span><br></pre></td></tr></table></figure><p>MappedByteBuffer的几个方法如下：</p><ol><li><code>load()</code>：加载整个文件至内存；该操作将会产生大量的页调入(page-in)，具体数量取决于文件中被映射区域的大小；该方法的主要作用是提前加载文件至内存以方便后续的访问速度尽可能的快</li><li><code>isLoaded()</code>：判断一个映射文件是否已经完全加载至内存</li><li><code>force()</code>： 同FileChannel的force方法，强制将缓冲区的修改应用到永久磁盘驱动器</li></ol><h2 id="Socket’s-Channel"><a href="#Socket’s-Channel" class="headerlink" title="Socket’s Channel"></a>Socket’s Channel</h2><p>新的Socket通道类可以运行非阻塞模式并且是可选择的。新旧两者对应关系如下：</p><ul><li><a href="http://www.365mini.com/page/java-nio-course-25.htm" target="_blank" rel="external">ServerSocketChannel</a>和ServerSocket</li><li><a href="http://www.365mini.com/page/java-nio-course-26.htm" target="_blank" rel="external">SocketChannel</a>和Socket</li><li><a href="http://www.365mini.com/page/java-nio-course-27.htm" target="_blank" rel="external">DatagramChannel</a>和DatagramSocket</li></ul><p>每个Socket’s Channel在实例化时都会创建一个对等的Socket对象，调用Channel中的<code>socket()</code>方法可获取到；而同时Socket对象也存在<code>getChannel()</code>方法，当且仅当通过Channel产生的对等Socket对象，调用<code>getChannel()</code>方法才会返回相应的Channel，若是使用传统的方式创建Socket，则调用该方法始终得到的是null</p><ol><li>连接实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接地址</span></span><br><span class="line">SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">10011</span>);</span><br><span class="line"><span class="comment">/******************** 服务端ServerSocketChannel通道创建 *************************/</span></span><br><span class="line"><span class="comment">// jdk1.7之前的bind方式</span></span><br><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.socket().bind(address);</span><br><span class="line"><span class="comment">// jdk1.7之后的bind方式</span></span><br><span class="line"><span class="comment">//ServerSocketChannel serverChannel = ServerSocketChannel.bind(address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 客户端SocketChannel通道创建 *************************/</span></span><br><span class="line">SocketChannel clientChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 通道连接</span></span><br><span class="line">clientChannel.connect(address);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Socket对象连接</span></span><br><span class="line"><span class="comment">//clientChannel.socket().connect(address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个Socket's Channel都继承自AbstractSelectableChannel，可控制通道是否阻塞</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">boolean</span>);</span><br><span class="line"><span class="comment">// 并且能够获取到修改阻塞方式的锁</span></span><br><span class="line">channel.blockingLock();</span><br></pre></td></tr></table></figure><h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h3><p><code>java.nio.channels</code>中含有一个名为<a href="http://www.365mini.com/page/java-nio-course-28.htm" target="_blank" rel="external"><code>Pipe</code>(管道)</a>的类，作用是使Java进程内部的两个通道(Channel)之间的数据传输;</p><p>核心知识：</p><ul><li>调用<code>Pipe.open()</code>方法创建</li><li><code>Pipe.SourceChannel</code>：负责读，调用<code>Pipe.source()</code>获取</li><li><code>Pipe.SlinkChannel</code>：负责写，调用<code>Pipe.slink()</code>获取</li></ul><h1 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a><a href="http://www.365mini.com/page/java-nio-course-30.htm" target="_blank" rel="external">Selector(选择器)</a></h1><p>选择器提供选择执行已经就绪任务的能力，其实现依赖底层操作系统的<code>select()</code>和<code>pool()</code>这两个系统调用，使得Java也能像C或C++提供同时管理多个I/O通道；</p><p><a href="http://www.365mini.com/page/java-nio-course-31.htm" target="_blank" rel="external">核心功能类</a>：</p><ul><li>Selector：多个Channel的监听者，通过<code>select()</code>方法实时响应就绪好的通道，<code>keys()</code>方法其返回的是SelectionKey对象</li><li>SelectorChannel：支持就绪检查的通道类的抽象；其可以被注册到Selector上，一个SelectorChannel可以被注册到多个Selector上，但对每个Selector而言每个SelectorChannel只能注册一次</li><li>SelectionKey：代指了通道与选择器之间的注册关系；</li></ul><p>具体细节可参考<a href="http://www.365mini.com/page/java-nio-course-32.htm" target="_blank" rel="external">NIO教程中的选择器</a>部分，这里就不做深入描述，之后研究select/pool/epoll的原理时再详细介绍其原理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.csdn.net/pwlazy/article/details/7370122" target="_blank" rel="external">理解java中的mmap</a></li><li><a href="http://www.365mini.com/page/java-nio-course-1.htm" target="_blank" rel="external">Java NIO入门教程详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客的初衷是记录了博主本次阅读系列博客(Java NIO入门教程详解—链接见文末)全文过程中的一些笔记，描述了Java NIO中核心类以及其方法的作用；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.ziwenzou.com/categories/Java/"/>
    
    
      <category term="nio" scheme="http://blog.ziwenzou.com/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存管理和持久化机制</title>
    <link href="http://blog.ziwenzou.com/2017/02/17/2017-02-17-redis_principle/"/>
    <id>http://blog.ziwenzou.com/2017/02/17/2017-02-17-redis_principle/</id>
    <published>2017-02-16T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:24.364Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客参考了多位前辈对Redis的深入分析的Blog和Redis实现原理等书籍，简单描述了Redis的内存管理和持久化机制，列出了其内存结构和编码类型，以及Redis持久化的RDB和AOF两种方式的基本原理<br><a id="more"></a></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Redis是一个基于内存的key-value的数据库，其内存管理是非常重要的；其针对不同操作系统的差异，同时方便自己实现相关的统计函数，封装了不同平台的实现，具体可参阅<a href="http://www.cnblogs.com/davidwang456/p/3504563.html" target="_blank" rel="external">深入redis内部—内存管理</a>；</p><p>Redis支持多种不同的数据类型，如下：</p><ul><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Sorted Set</li></ul><p>下面就详细来介绍下其数据结构和编码。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>所有的Redis对象都被封装在RedisObject这个结构体当中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type,           <span class="comment">// 4字节，数据类型(String,List,Set,Hash,Sorted Set)</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding,   <span class="comment">// 4字节，编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru,              <span class="comment">// 24字节</span></span><br><span class="line">    <span class="keyword">int</span> refcount,               <span class="comment">// 对象引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr                    <span class="comment">// 数据具体存储的指向</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>数据类型的常用编码方式如下：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>常用</th><th>少量数据</th><th>特殊情况</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>String</td><td>RAW</td><td>EMBSTR</td><td>INT</td><td>O(1)</td><td>O(1)</td></tr><tr><td>List</td><td>LinkedList</td><td>ZipList</td><td></td><td>pop:O(1)<br>lset:O(N)</td><td>push:O(1)<br>lindex:O(N)</td></tr><tr><td>Set</td><td>Hash Table</td><td></td><td>INTSET(少量整数)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>Hash</td><td>Hash Table</td><td>ZipList</td><td></td><td>O(1)</td><td>O(1)</td></tr><tr><td>Sorted Set</td><td>SkipList</td><td>ZipList</td><td></td><td>zscore:O(1)<br>zrank:O(logN)</td><td>O(logN) </td></tr></tbody></table></div><p>编码方式介绍：</p><ul><li>RAW：RedisObject的ptr指向名为sds的空间，包含Len和Free头部和buf的实际数据，Free采用了某种预分配（若Len<1m，则free分配与len大小一致的空间；若大于len>=1M，则Free分配1M空间；SDS的长度为Len+Free+buf+1(额外的1字节用于保存空字符)）</1m，则free分配与len大小一致的空间；若大于len></li><li>EMBSTR：与RedisObject在连续的一块内存空间，省去了多次内存分配；条件是字符串长度&lt;=39</li><li>INT：字符串的特殊编码方式，若存储的字符串是整数时，则ptr本身会等于该整数，省去了sds的空间开销；实际上Redis在启动时会默认创建10000个RedisObject，代表0-10000的整数</li><li>ZipList(压缩列表)：除了一些标志性字段外用一块类似数组的连续空间来进行存储，缺点是读写时整个压缩列表都需要更改，一般能达到10倍的压缩比。Hash默认值为512，List默认是64</li><li>Hash Table：默认初始大小为4，使用链地址法解决hash冲突；rehash策略：将原来表中的数据rehash并放入新表，之后替换；大量rehash可能会造成服务不可用，因此Redis使用渐进式rehash策略，分批进行</li></ul><h3 id="过期机制"><a href="#过期机制" class="headerlink" title="过期机制"></a>过期机制</h3><p>Redis为了不影响正常的读写操作，一般只会在必要或CPU空闲的时候做过期清理的动作；</p><ol><li>必要：一次事件循环结束，进入事件侦听前</li><li>CPU空闲：系统空闲时做后台定时清理任务（时间限制为25%的CPU时间）；Redis后台清理任务默认100ms执行1次，25%限制是表示25ms用来执行key清理</li></ol><p>过期key清理算法：</p><ol><li>依次遍历所有db；</li><li>从db中随机取得20个key，判断是否过期，若过期，则剔除；</li><li>若有5个以上的key的过期，则重复步骤2，否则遍历下一个db</li><li>清理过程中若达到了时间限制，则退出清理过程</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis支持四种持久化方式；如下：</p><ul><li>定时快照方式(snapshot)[RDB方式]</li><li>基于语句追加文件的方式(aof)</li><li>虚拟内存(vm) <font color="red">已被放弃</font></li><li>Diskstore方式<font color="red">实验阶段</font></li></ul><p>前两种方式为小数据量追加落地方式；后两种为尝试存储数据超过物理内存时，一次性落地方式；</p><h3 id="定时快照方式-snapshot"><a href="#定时快照方式-snapshot" class="headerlink" title="定时快照方式(snapshot)"></a>定时快照方式(snapshot)</h3><p>该方式实际是在Redis内部执行一个定时任务，根据redis.conf中配置的save的时间间隔去检查当前数据改变次数和时间是否满足配置，如果满足则从父进程fork(copy-on-write机制)出一个子进程，通过该子进程遍历内存来转换成rdb文件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Save the DB on disk:</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）。</span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）。</span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）。</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"> </span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 在进行镜像备份时,是否进行压缩。yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间。</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 一个CRC64的校验就被放在了文件末尾，当存储或者加载rbd文件的时候会有一个10%左右的性能下降，为了达到性能的最大化，你可以关掉这个配置项。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"># 快照的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 存放快照的目录</span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure><p>缺陷：快照只是一段时间的数据的体现，若发生宕机，数据会丢失</p><h3 id="基于语句追加文件的方式-aof"><a href="#基于语句追加文件的方式-aof" class="headerlink" title="基于语句追加文件的方式(aof)"></a>基于语句追加文件的方式(aof)</h3><p>类似mysql的binlog方式，每个数据发生改变都会追加至一个log文件中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启AOF，默认关闭（no）</span><br><span class="line">appendonly yes</span><br><span class="line"># 指定 AOF 文件名</span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"># Redis支持三种不同的刷写模式：</span><br><span class="line"># appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。</span><br><span class="line">appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。</span><br><span class="line"># appendfsync no #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。</span><br></pre></td></tr></table></figure><p>缺陷：追加log文件可能过大，恢复慢；实时写log会影响redis本身性能</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage" target="_blank" rel="external">Redis内存使用优化与存储</a></li><li><a href="http://www.cnblogs.com/zhoujinyi/archive/2013/05/26/3098508.html" target="_blank" rel="external">Redis持久化 Snapshot和AOF说明</a></li><li><a href="https://yq.aliyun.com/articles/67122" target="_blank" rel="external">细解Redis内存管理和优化</a></li><li><a href="http://redisbook.com/" target="_blank" rel="external">Redis 设计与实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客参考了多位前辈对Redis的深入分析的Blog和Redis实现原理等书籍，简单描述了Redis的内存管理和持久化机制，列出了其内存结构和编码类型，以及Redis持久化的RDB和AOF两种方式的基本原理&lt;br&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://blog.ziwenzou.com/categories/Knowledge/"/>
    
    
      <category term="redis" scheme="http://blog.ziwenzou.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>JMM概述</title>
    <link href="http://blog.ziwenzou.com/2017/02/13/2017-02-13-jmm/"/>
    <id>http://blog.ziwenzou.com/2017/02/13/2017-02-13-jmm/</id>
    <published>2017-02-12T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:29.166Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客旨在突出体现JMM的基本作用，以及其特性；当然面试中也有很多朋友会遇到这个题目，简单了解下还是有助于找工作的。<br><a id="more"></a></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本篇博客旨在突出体现JMM的基本作用，以及其特性；当然面试中也有很多朋友会遇到这个题目，简单了解下还是有助于找工作的。</p><h1 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h1><blockquote><p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p></blockquote><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化</p><h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>为了程序能够更高效的运行，编译器和处理器都会对指令进行重排序；重排序分为以下三种类型：</p><ol><li>编译器优化的重排序</li><li>指令级并行的重排序</li><li>内存系统的重排序</li></ol><p><strong>只要是重排序都有可能会导致多线程内出现内存可见性的问题</strong></p><h2 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h2><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p><div class="table-container"><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1; StoreStore; Store2</td><td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1; LoadStore; Store2</td><td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1; StoreLoad; Load2</td><td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td></tr></tbody></table></div><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><blockquote><p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p></blockquote><p>happens-before规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li><li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li></ul><p><strong>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前</strong></p><h1 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h1><blockquote><p>JMM对正确同步的多线程程序，其执行将具有顺序一致性(sequentially consistent)—-即程序的执行结果和在顺序一致性模型中得到的结果相同；（这里同步是指广义上的同步，包括同步原语(lock,volatile,final)的正确使用）</p></blockquote><p>特性：</p><ul><li>一个线程中所有操作都必须按照程序的顺序来执行</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在此模型下，每个操作都必须原子执行且立即对所有线程可见</li></ul><h1 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h1><p>JMM还定义了volatile、锁、final的内存语义，具体细节已经有同仁总结的很好了，所以这里就不多阐述了。</p><p>附上链接：</p><ul><li><a href="http://www.infoq.com/cn/articles/java-memory-model-4" target="_blank" rel="external">volatile</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="external">锁</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-6" target="_blank" rel="external">final</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客旨在突出体现JMM的基本作用，以及其特性；当然面试中也有很多朋友会遇到这个题目，简单了解下还是有助于找工作的。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.ziwenzou.com/categories/Java/"/>
    
    
      <category term="jmm" scheme="http://blog.ziwenzou.com/tags/jmm/"/>
    
  </entry>
  
  <entry>
    <title>Pushy初识</title>
    <link href="http://blog.ziwenzou.com/2017/01/17/2017-01-17-pushy/"/>
    <id>http://blog.ziwenzou.com/2017/01/17/2017-01-17-pushy/</id>
    <published>2017-01-16T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:34.687Z</updated>
    
    <content type="html"><![CDATA[<p>Pushy是基于HTTP/2的Java类库，是向Apple的APNs发送推送通知的第三方类库。</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><a href="https://github.com/relayrides/pushy" target="_blank" rel="external">Pushy</a>是一个给Apns的发推送通知的Java类库；是<a href="https://turo.com/" target="_blank" rel="external">Turo</a>创建和维护的项目。</p><p>与<a href="https://github.com/notnoop/java-apns" target="_blank" rel="external">notnoop</a>使用基于二进制协议不同的是，Pushy使用的是基于HTTP/2-based APNs 协议</p><p><strong>具体两种协议的比较可参考：<a href="https://github.com/ChenYilong/iOS9AdaptationTips/blob/master/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE.md" target="_blank" rel="external">基于HTTP2的全新APNs协议</a></strong></p><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pushy --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.relayrides&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;pushy&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.8.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.netty&lt;/groupId&gt;  </span><br><span class="line">   &lt;artifactId&gt;netty-tcnative-boringssl-static&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.33.Fork24&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.eclipse.jetty.alpn/alpn-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.eclipse.jetty.alpn&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;alpn-api&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.2.v20150522&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>作为一个程序员，果断上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.ApnsClient;</span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.ApnsClientBuilder;</span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.ClientNotConnectedException;</span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.PushNotificationResponse;</span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.util.ApnsPayloadBuilder;</span><br><span class="line"><span class="keyword">import</span> com.relayrides.pushy.apns.util.SimpleApnsPushNotification;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GenericFutureListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ApnsClient apnsClient = <span class="keyword">new</span> ApnsClientBuilder()</span><br><span class="line">.setClientCredentials(<span class="keyword">new</span> File(<span class="string">"p12Path"</span>), <span class="string">"111111"</span>).build();</span><br><span class="line"><span class="keyword">final</span> Future&lt;Void&gt; connectFutrue = apnsClient.connect(ApnsClient.DEVELOPMENT_APNS_HOST);</span><br><span class="line"><span class="comment">// 等待连接apns成功, 良好的编程习惯，需要有最长等待时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">connectFutrue.await(<span class="number">10</span> , TimeUnit.MINUTES);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> InterruptedException) &#123;</span><br><span class="line">System.out.println(<span class="string">"Failed to connect APNs , timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> ApnsPayloadBuilder payBuilder = <span class="keyword">new</span> ApnsPayloadBuilder();</span><br><span class="line">payBuilder.setAlertBody(<span class="string">"pushy Example"</span>);</span><br><span class="line">String payload = payBuilder.buildWithDefaultMaximumLength();</span><br><span class="line"><span class="keyword">final</span> String token = <span class="string">"******"</span>;</span><br><span class="line">SimpleApnsPushNotification notification = <span class="keyword">new</span> SimpleApnsPushNotification(token, <span class="keyword">null</span>, payload);</span><br><span class="line">Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; responseFuture = apnsClient</span><br><span class="line">.sendNotification(notification);</span><br><span class="line">responseFuture</span><br><span class="line">.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; arg0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> PushNotificationResponse&lt;SimpleApnsPushNotification&gt; pushNotificationResponse = arg0</span><br><span class="line">.get();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pushNotificationResponse.isAccepted()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Push notification accepted by APNs gateway."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Notification rejected by the APNs gateway: "</span></span><br><span class="line">+ pushNotificationResponse.getRejectionReason());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pushNotificationResponse.getTokenInvalidationTimestamp() != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"\t…and the token is invalid as of "</span></span><br><span class="line">+ pushNotificationResponse.getTokenInvalidationTimestamp());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ExecutionException e) &#123;</span><br><span class="line">System.err.println(<span class="string">"Failed to send push notification."</span>);</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> ClientNotConnectedException) &#123;</span><br><span class="line">System.out.println(<span class="string">"Waiting for client to reconnect…"</span>);</span><br><span class="line">apnsClient.getReconnectionFuture().await();</span><br><span class="line">System.out.println(<span class="string">"Reconnected."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结束后关闭连接, 该操作会直到所有notification都发送完毕并回复状态后关闭连接</span></span><br><span class="line">Future&lt;Void&gt; disconnectFuture = apnsClient.disconnect();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">disconnectFuture.await(<span class="number">1</span> , TimeUnit.HOURS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> InterruptedException) &#123;</span><br><span class="line">System.out.println(<span class="string">"Failed to disconnect APNs , timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Error-Lists"><a href="#Error-Lists" class="headerlink" title="Error Lists"></a>Error Lists</h1><ul><li>java.lang.NoClassDefFoundError: org/eclipse/jetty/alpn/ALPN$Provider<br>Maven中添加如下配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;netty-tcnative-boringssl-static&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.33.Fork24&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.eclipse.jetty.alpn/alpn-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.eclipse.jetty.alpn&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;alpn-api&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.2.v20150522&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>error:10000438:SSL routines:OPENSSL_internal:TLSV1_ALERT_INTERNAL_ERROR<br>证书错误，更换证书即可</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pushy是基于HTTP/2的Java类库，是向Apple的APNs发送推送通知的第三方类库。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://blog.ziwenzou.com/categories/Knowledge/"/>
    
    
      <category term="apns" scheme="http://blog.ziwenzou.com/tags/apns/"/>
    
  </entry>
  
  <entry>
    <title>排序算法概括</title>
    <link href="http://blog.ziwenzou.com/2017/01/10/2017-01-10-sort_algorithm/"/>
    <id>http://blog.ziwenzou.com/2017/01/10/2017-01-10-sort_algorithm/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:38.936Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法作为数据结构与算法的基础知识，在实际开发中有许多的应用；当然还有更重要的一点，排序算法几乎属于面试必问的知识。博主个人对排序算法做了一些概括，如下文。<br><a id="more"></a></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p> 排序总共分为五类：</p><ol><li>插入排序：直接插入排序，希尔排序</li><li>选择排序：直接选择排序，堆排序</li><li>交换排序：冒泡排序，快速排序</li><li>归并排序</li><li><p>基数排序</p><p>下文将分别用一段话来概述其算法的实现；</p></li></ol><h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. 插入排序</h1><blockquote><p>插入排序是通过构建有序序列的基础上，对于未排序数据从后向前扫描，并找出相应位置插入的过程</p></blockquote><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p><strong>基本思想</strong>：顺序地将待排序的数据元素按其关键字值的大小插入到已排序数据元素子集合的适当位置。子集合的数据元素个数从只有一个数据元素开始逐次增大，当子集合大小最终与集合大小相同时排序完毕。</p><p>通俗地来讲，有一数组a，长度为n,初始第一个元素为集合R{a1}，依次为R{a1,a2}、R{a1,a2,a3}、…..、R{a1,a2,a3,….,an}排序;最终R{a1,a2,a3,….,an}排序的结果即排序完毕；<strong>(Notes:集合顺序不一定是R{a1,a2,a3})</strong></p><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/insert/InsertionSort.java" target="_blank" rel="external">InsertionSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(n)</span><br><span class="line">    2. 平均：O(n^2)</span><br><span class="line">    3. 最坏：O(n^2)</span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure><h2 id="1-2-希尔插入排序"><a href="#1-2-希尔插入排序" class="headerlink" title="1.2 希尔插入排序"></a>1.2 希尔插入排序</h2><p><strong>基本思想</strong>：把待排序的数据元素分成若干个小组，对同一小组内的数据元素用直接插入法排序；小组的个数逐次缩小，当完成了所有数据元素都在一个组内的排序后排序过程结束。希尔排序又称作为缩小增量排序。</p><p>通俗地来讲，有一数组a，长度为n,<code>并设定一组增量</code>,并将数组a按增量进行分组，例如有一增量为3，则分组为R{a1,a4,a7…..},R{a2,a5,a8…}等;再将分组好的数组进行插入排序。</p><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/insert/ShellSort.java" target="_blank" rel="external">ShellSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(n)</span><br><span class="line">    2. 平均：O((nlog(n))^2)    </span><br><span class="line">    3. 最坏：O((nlog(n))^2)    </span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure><p><strong>增量的选择</strong>：</p><ol><li>最后一个增量必须为1</li><li>应避免增量序列中的取值为倍数（尤其是相邻的值），否则会发生重复比较</li></ol><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h1><blockquote><p>选择排序是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完</p></blockquote><h2 id="2-1-直接选择排序"><a href="#2-1-直接选择排序" class="headerlink" title="2.1 直接选择排序"></a>2.1 直接选择排序</h2><p><strong>基本思想</strong>：有一数组R{a0,..,an-1}，按顺序从R{a0,..,an-1},R{a1,…,an-1},…….,R{an-2,an-1}中选取出最小值，该值与每次数组中的第一个元素进行交换,总共需要n-1次，得到一个排好序的有序序列。</p><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/select/SelectSort.java" target="_blank" rel="external">SelectSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(n^2)    </span><br><span class="line">    2. 平均：O(n^2)    </span><br><span class="line">    3. 最坏：O(n^2)    </span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure><h2 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h2><p><strong>基本思想</strong>：即把<code>最大堆</code>堆顶的最大数取出，之后将剩余的堆重新调整为最大堆，并再次将堆顶的最大数取出，直到堆中最后一个数被取出时结束。一般堆中有如下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆中所有数据重排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在最大堆中的堆顶元素，并递归调用最大堆调整运算</li></ul><p>堆排序中几个重要的节点计算公式：</p><ol><li>父节点：(i-1)/2，i的父节点下标</li><li>子节点(左)：2i + 1，i的左子节点下标</li><li>子节点(右)：2(i+1)，i的右子节点下标</li></ol><p>最大堆与最小堆定义：</p><ul><li>最大堆(大根堆)：堆顶元素(根节点)的值是堆中所有值中最大值</li><li>最小堆(小根堆)：堆顶元素(根节点)的值是堆中所有值中最小值</li></ul><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/select/HeapSort.java" target="_blank" rel="external">HeapSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(nlog(n))</span><br><span class="line">    2. 平均：O(nlog(n))</span><br><span class="line">    3. 最坏：O(nlog(n))</span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure><h1 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3. 交换排序"></a>3. 交换排序</h1><blockquote><p>交换排序是将序列中的值进行比较并按大小进行交换位置；特点为：将值大的数据向序列尾部一定，将值小的数据向序列头部移动</p></blockquote><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h2><p><strong>基本思想</strong>：对每一对相邻元素作比较大小，并按照大小交换位置。</p><ol><li>从a0-an数组中，进行相邻元素比较，较大者则与较小者交换位置，这样一次完整比较后则最后一个元素即为最大值</li><li>剩余a0-an-1为未排序的序列；重复1）步骤，不过是从a0-an-1数组中进行元素比较</li><li>持续每次对越来越少的数组重复上述的步骤，直到没有任何一对元素需要比较</li></ol><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/convert/BubbleSort.java" target="_blank" rel="external">BubbleSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(n)    </span><br><span class="line">    2. 平均：O(n^2)    </span><br><span class="line">    3. 最坏：O(n^2)    </span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure><h2 id="3-2-快速排序"><a href="#3-2-快速排序" class="headerlink" title="3.2 快速排序"></a>3.2 快速排序</h2><p><strong>基本思想</strong>：快速排序是基于分治法处理的，步骤如下：</p><ol><li>分解：将数组a[p,r]划分成两个子数组a[p,q-1]和a[q+1,r],使得A[p,q-1] &lt;= A[q] &lt;= A[q+1,r]</li><li>解决：递归调用[分解]步骤，分别对两个子数组进行分解</li><li>合并：将最终结果进行合并</li></ol><p>简单地说，就是将数组a[p,r]按数组中的某个值(<code>基准</code>)划分，小于该值的归为一个数组，大于该值的归为一个数组；之后重复对分解后的数组进行递归操作。</p><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/convert/QuickSort.java" target="_blank" rel="external">QuickSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(nlog(n))</span><br><span class="line">    2. 平均：O(nlog(n))</span><br><span class="line">    3. 最坏：O(n^2)    </span><br><span class="line">空间复杂度：O(n log(n))</span><br></pre></td></tr></table></figure><h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><p><strong>基本思想</strong>：归并排序也是基于分治法处理的；归并排序分为多路归并和两路归并，可用与外排序和内排序；这里主要讲下内排序的两路归并方式。</p><ol><li>分解：将数组a[p,r]分为(r-p)/2个长度为2的数组，并使每个数组都有序</li><li>合并：将子数组两两合并，最终合成的数据则已经排好序</li></ol><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/other/MergeSort.java" target="_blank" rel="external">MergeSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(nlog(n))</span><br><span class="line">    2. 平均：O(nlog(n))</span><br><span class="line">    3. 最坏：O(n^2)    </span><br><span class="line">空间复杂度：O(n)</span><br></pre></td></tr></table></figure><h1 id="5-基数排序"><a href="#5-基数排序" class="headerlink" title="5. 基数排序"></a>5. 基数排序</h1><p><strong>基本思想</strong>：将数组序列中的数(<code>必须为正整数</code>)都统一成相同数位，超出位数前面补零；然后从最低位开始，依次按个位、十位、百位….(具体按数的位数决定)的方式进行多次排序，最终则为有序序列；</p><p>Java代码详见：<a href="https://github.com/mastery001/study/blob/master/study-datastruct/src/main/java/sort/other/RadixSort.java" target="_blank" rel="external">RadixSort.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">    1. 最佳：O(nk)</span><br><span class="line">    2. 平均：O(nk)</span><br><span class="line">    3. 最坏：O(nk)</span><br><span class="line">空间复杂度：O(n+k)</span><br><span class="line">k为无序序列中最大值的数位10^k，例如98-&gt;10^2;故k=2</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要阐述了这些排序算法的基本思想和时间复杂度等情况，并附上了本人写的代码；写此文的初衷亦是为了巩固自己的排序算法基础，如果表述不当的地方请阅读了本文的朋友多指教。谢谢！</p><p>附上一些排序算法的不错的blog：</p><ul><li><a href="http://bubkoo.com/tags/algorithm/" target="_blank" rel="external">http://bubkoo.com/tags/algorithm/</a></li><li><a href="http://wiki.jikexueyuan.com/project/data-structure-sorting/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/data-structure-sorting/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法作为数据结构与算法的基础知识，在实际开发中有许多的应用；当然还有更重要的一点，排序算法几乎属于面试必问的知识。博主个人对排序算法做了一些概括，如下文。&lt;br&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="http://blog.ziwenzou.com/categories/DataStructure/"/>
    
    
      <category term="sort" scheme="http://blog.ziwenzou.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>接口响应时间长的调优经验</title>
    <link href="http://blog.ziwenzou.com/2017/01/06/2017-01-06-service_architecture/"/>
    <id>http://blog.ziwenzou.com/2017/01/06/2017-01-06-service_architecture/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:49.060Z</updated>
    
    <content type="html"><![CDATA[<p>随着移动互联网的兴起，海量的终端带来的是数据量的飞速增长，对于存储的需求也随之增长；随之引发的接口响应率等问题也不断暴露…..<br><a id="more"></a></p><h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>业务之初采用的技术架构：</p><ol><li>使用单库单表进行存储app信息</li><li>接口层面与库直接交互操作</li></ol><p>服务状态：</p><ul><li>数据库采用NoSql中的MongoDB；</li><li>接口每日请求<code>10</code>亿，超时率在<code>15%</code>左右</li></ul><h1 id="数据量激增带来的问题"><a href="#数据量激增带来的问题" class="headerlink" title="数据量激增带来的问题"></a>数据量激增带来的问题</h1><p>数据量的激增给我们的系统带来了哪些挑战？</p><ol><li>使用单表存储导致单表数据量过大，索引数据过大；存储+索引竟达到200G</li><li>接口直接与库操作导致接口响应(请求时间&gt;100ms)缓慢；MongoDB是基于内存的数据库，单库单表特别影响性能</li><li>推送时直接走库导致推送过慢</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>为了提高接口的性能，并通过一步步的引入缓存、队列等中间件减少数据库的读请求和分离数据库的写请求，且对线程池的调优。</p><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>此版本接入了缓存Redis(<a href="https://github.com/CodisLabs/codis" target="_blank" rel="external">Codis集群</a>)，通过Redis的高性能以及多样的数据结构来减少直接查询数据库的操作。</p><p>友情链接：<a href="http://redis.cn/documentation.html" target="_blank" rel="external">Redis文档-中文版</a></p><p><strong>注意事项：</strong></p><ol><li>需要考虑<a href="http://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="external">缓存穿透和缓存雪崩</a>的情况；</li><li>缓存与数据库的数据一致性问题<ul><li><a href="http://www.36dsj.com/archives/43950" target="_blank" rel="external">缓存与数据库一致性保证</a></li><li><a href="https://www.oschina.net/question/259473_167708" target="_blank" rel="external">如何校验数据库和缓存之间数据的一致性</a></li></ul></li></ol><p><strong>接入缓存后，数据库的请求减少，接口超时率平均在<code>10%</code>左右，在晚高峰时段还是能达<code>10%</code>左右</strong></p><p>尚未解决问题：</p><ol><li>接口内直接对库进行写操作</li><li>Mongo数据库单表数据量达到亿级，并且存在无效索引</li></ol><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>此版本接入了队列，通过队列将数据库插入和修改操作在队列消费端操作，在接口中隔离了对数据库的操作。</p><p>引入队列后，博主以为接口应该不会超时了，虽然<code>数据库的数据量</code>比较大，CRUD比较慢，可接口中已经将写操作清零，读操作减少一大半。查询<code>nginx日志</code>发现超时尽管有所减少，但超时每秒还是有几百，总体每日平均超时为<code>5%</code>左右。</p><p>这个问题让我有点想不通，于是博主便想着去看下Java线程是否可以调优，目前系统使用的是Netty4作为容器，监听端口来响应；作了以下事情：</p><ol><li>查看GC日志，配合<a href="http://www.tongtech.com/upload_files/files/doc/56.pdf" target="_blank" rel="external">jstat命令</a>查询GC频率，是否出现频繁GC，或者Full GC次数过多等情况</li><li>查看线程日志，配合<a href="http://www.cnblogs.com/chenpi/p/5377445.html" target="_blank" rel="external">jstack命令</a>分析是否出现线程死锁，Object.wait()情况</li><li>通过jdk自带的jmc工具观察堆内存使用情况；也可观察线程占用CPU百分比</li></ol><p>通过上面的三步操作，得到结果：</p><ul><li>GC频率不高，Full GC几乎没有</li><li>内存使用正常，尚未超过临界值</li><li>通过jstack发现大量的线程处于WAITING状态，可是在jstack中尚未发现是哪个方法是引起WAITING的元凶</li></ul><p>于是去网上找资料，如何能定位某个方法的执行时间，找到了jdk自带的<a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/" target="_blank" rel="external">jvisualvm工具</a>[Notes：jdk1.7u45后才自带有该工具，否则需要自行安装]</p><p>打开jvisualvm-&gt;远程-&gt;添加JMX连接-&gt;抽样器-&gt;CPU-&gt;在CPU样例中点击快照</p><p><strong>Notes:快照需要等一两分钟跑了数据后再进行生成，一般生成两三次快照进行观察对比。</strong></p><p>博主通过jvisualvm的快照中发现大量的线程在自己实现的业务handler中处理时间过长，在这里友情链接下<a href="http://www.importnew.com/15656.html" target="_blank" rel="external">Netty的实现原理</a></p><p>由于业务handler线程只开启了CPU*2个，导致<code>io线程阻塞</code>，无法接收新的请求，超时率高。于是博主将线程数调高，<code>超时率已经只有1%左右</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下面附上个人对Netty线程的理解：</span><br><span class="line"></span><br><span class="line">netty是基于boss，worker，handler三者相同配合的nio框架</span><br><span class="line"></span><br><span class="line">1. boss：负责接收io请求，实际情况下，如果只监听了一个端口，只需要开启一个boss</span><br><span class="line">2. worker： 负责处理io请求，一般个数不要超过CPU核数，默认为CPU\*2，超过反而影响性能</span><br><span class="line">3. handler：负责处理业务的线程，如果是在高并发环境，可以将线程数调大，但一台机器的线程数最好`不要超过1000`，否则影响性能。将线程数调大可以防止worker堵塞。</span><br></pre></td></tr></table></figure><h2 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h2><blockquote><p>在版本1和2中分别在业务架构上引入了缓存和队列，并进行了线程调优，缓解了大部分的接口压力，提升了接口响应时间；</p><p>此版本将就Mongo的基础进行优化。</p></blockquote><p>关于Mongo的实现可参阅官方文档：<a href="https://docs.mongodb.com/manual/" target="_blank" rel="external">MongoDB Manual</a></p><p>上文中提到过数据存储用Mongo，并采用单库单表的形式在存储app数据，并且由于历史原因存在无效索引；所以可采取以下方式：</p><ol><li>删除无效索引，减少索引占用的内存</li><li>由于Mongo内存管理部分完全交由操作系统内核处理，在执行<code>update或delete</code>操作时容易产生内存碎片，导致运行时间过长容易造成大量内存无法被利用。所以需要<code>定期回收Mongo空间，释放内存</code>(具体方式请自行Google)</li><li>将数据库单库单表形式变成多库多表，进行水平拆分，<ul><li>将设备与app的关系存储在按Hash取模的方式的表中，</li><li>将大表拆分，按app分表存储</li></ul></li></ol><p>下面附上MongoDB在使用过程中的一些优化建议：<a href="http://snoopyxdy.blog.163.com/blog/static/6011744020157511536993/" target="_blank" rel="external">Mongodb 实战优化</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇博客意在总结本次调优过程中的大体思路，具体一些工具的使用细节请大家自行查阅资料。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着移动互联网的兴起，海量的终端带来的是数据量的飞速增长，对于存储的需求也随之增长；随之引发的接口响应率等问题也不断暴露…..&lt;br&gt;
    
    </summary>
    
      <category term="Experience" scheme="http://blog.ziwenzou.com/categories/Experience/"/>
    
    
      <category term="architecture" scheme="http://blog.ziwenzou.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Redis scan命令的一次坑</title>
    <link href="http://blog.ziwenzou.com/2016/12/05/2016-12-05-redis_scan_notice/"/>
    <id>http://blog.ziwenzou.com/2016/12/05/2016-12-05-redis_scan_notice/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-11-11T14:58:59.030Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为当前服务架构不可或缺的Cache，其支持丰富多样的数据结构，Redis在使用中其实也有很多坑，本次博主遇到的坑或许说是Java程序员会遇到的多一点，下面就听博主详细道来。</p><a id="more"></a><h1 id="线上服务堵塞"><a href="#线上服务堵塞" class="headerlink" title="线上服务堵塞"></a>线上服务堵塞</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String key = keyOf(appid);</span><br><span class="line">int retryCount = 3;</span><br><span class="line">int socketRetryCount = 3;</span><br><span class="line">Exception ex = null;</span><br><span class="line">while(retryCount &gt; 0 &amp;&amp; socketRetryCount &gt; 0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return redisDao.getMap(key);</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12月2日被告知服务出现异常，查看日志发现其运行到上述代码getMap方法处后日志就没有内容了。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&quot;pool-13-thread-6&quot; prio=10 tid=0x00007f754800e800 nid=0x71b5 waiting on condition [0x00007f758f0ee000]</span><br><span class="line">java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x0000000779b75f40&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">at org.apache.commons.pool2.impl.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:583)</span><br><span class="line">at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:442)</span><br><span class="line">at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:363)</span><br><span class="line">at redis.clients.util.Pool.getResource(Pool.java:49)</span><br><span class="line">at redis.clients.jedis.JedisPool.getResource(JedisPool.java:99)</span><br><span class="line">at org.reborndb.reborn.RoundRobinJedisPool.getResource(RoundRobinJedisPool.java:300)</span><br><span class="line">at com.le.smartconnect.adapter.spring.RebornConnectionFactory.getConnection(RebornConnectionFactory.java:43)</span><br><span class="line">at org.springframework.data.redis.core.RedisConnectionUtils.doGetConnection(RedisConnectionUtils.java:128)</span><br><span class="line">at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:91)</span><br><span class="line">at org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:78)</span><br><span class="line">at xxx.run(xxx.java:80)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:262)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Locked ownable synchronizers:</span><br><span class="line">- &lt;0x000000074f529b08&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br></pre></td></tr></table></figure><p>从线程日志可以看出服务堵塞在<code>获取redis连接</code>处.</p><p>分析：</p><ul><li>代码配置中redis最大连接为<code>3000</code></li><li>redis配置中<code>session_max_timeout</code>为0，即永不断开连接</li></ul><h2 id="一次修改分析"><a href="#一次修改分析" class="headerlink" title="一次修改分析"></a>一次修改分析</h2><p>从以上两点分析得出，redis连接被耗尽，于是查找代码得知由于重写spring-data-redis中的hscan方面导致，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">RedisConnection rc = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"><span class="keyword">if</span> (rc <span class="keyword">instanceof</span> JedisConnection) &#123;</span><br><span class="line">JedisConnection JedisConnection = (JedisConnection) rc;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConvertingCursor&lt;Map.Entry&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;, Map.Entry&lt;String, String&gt;&gt;(</span><br><span class="line">JedisConnection.hScan(rawValue(key), cursor, scanOptions),</span><br><span class="line"><span class="keyword">new</span> Converter&lt;Map.Entry&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;, Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entry&lt;String, String&gt; <span class="title">convert</span><span class="params">(<span class="keyword">final</span> Entry&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Map.Entry&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hashKeySerializer.deserialize(source.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hashValueSerializer.deserialize(source.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"Values cannot be set when scanning through entries."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hashOps.scan(key, scanOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码返回ConvertingCursor后未释放连接，导出连接被占满。</p><h2 id="二次修改分析"><a href="#二次修改分析" class="headerlink" title="二次修改分析"></a>二次修改分析</h2><p>于是修改代码为正常释放连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">...</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">RedisConnectionUtils.releaseConnection(rc, factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码经过上线，再次跑程序查看线上日志发现报了大量的Connection time out.</p><p>于是博主就思考是不是由于重写代码不对，尝试使用spring-data-redis的原生代码，即直接调用<code>hashOps.scan(key, scanOptions)</code>方法，再次上线。</p><p>上线后观察日志：发现这次不是报<code>Connection time out</code>,日志中大量报<code>Unknown reply:</code>错误。</p><p>分析如下：</p><p>由于代码是在多线程环境下运行，有几百个线程去调用hscan操作，spring-data-redis原生的代码执行完一次hscan操作后就会关闭连接并返回一个迭代器Cursor，但是遍历Cursor时在本次count后会再次根据游标重新使用该连接进行查询，可是连接却已经被关闭，这时会使用新的连接是可以正常迭代的，但是一旦复用到其他线程使用的连接则会导致报错<code>Unknown reply</code>.</p><h2 id="三次修改分析"><a href="#三次修改分析" class="headerlink" title="三次修改分析"></a>三次修改分析</h2><p>经过思考后得出结论，redis在执行scan操作时一旦连接被释放，那么scan操作将不会进行下去，则报Connection time out. </p><p>查阅官方文档得出结论，redis的scan操作需要full iteration，即最优方式是一个连接将以此scan任务执行完全后释放该连接。</p><p><img src="/images/redis_scan/scan_doc.png" alt="redis-scan-doc"></p><p>修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RedisConnectionFactory factory = redisTemplate.getConnectionFactory();</span><br><span class="line">RedisConnection rc = factory.getConnection();</span><br><span class="line"><span class="keyword">if</span> (rc <span class="keyword">instanceof</span> JedisConnection) &#123;</span><br><span class="line">JedisConnection JedisConnection = (JedisConnection) rc;</span><br><span class="line">Cursor&lt;Map.Entry&lt;String, String&gt;&gt; cursorResult = <span class="keyword">new</span> ConvertingCursor&lt;Map.Entry&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;, Map.Entry&lt;String, String&gt;&gt;(</span><br><span class="line">JedisConnection.hScan(rawValue(key), cursor, scanOptions),</span><br><span class="line"><span class="keyword">new</span> Converter&lt;Map.Entry&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;, Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScanResult&lt;Map.Entry&lt;String, String&gt;&gt;(cursorResult, factory, rc);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">IOException ex = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cursor.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">ex = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RedisConnectionUtils.releaseConnection(rc, factory);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ex != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将连接返回给业务代码，并在业务代码执行完毕后将连接释放，问题解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>连接一旦开启就必须释放，否则造成内存泄漏或服务堵塞不可用</li><li>重写代码时需要谨记仔细查阅官方文档给出的方案并实施</li><li>多线程下使用redis的scan操作需要使用一个连接遍历完Cursor，而不能复用连接，否则导致报错<code>Unknown reply.</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis作为当前服务架构不可或缺的Cache，其支持丰富多样的数据结构，Redis在使用中其实也有很多坑，本次博主遇到的坑或许说是Java程序员会遇到的多一点，下面就听博主详细道来。&lt;/p&gt;
    
    </summary>
    
      <category term="Experience" scheme="http://blog.ziwenzou.com/categories/Experience/"/>
    
    
      <category term="cache" scheme="http://blog.ziwenzou.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Codis初体验心得</title>
    <link href="http://blog.ziwenzou.com/2016/09/22/2016-09-22-codis_introduction/"/>
    <id>http://blog.ziwenzou.com/2016/09/22/2016-09-22-codis_introduction/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2017-11-11T14:59:09.428Z</updated>
    
    <content type="html"><![CDATA[<p>Codis是一个分布式的Redis解决方案，对于上层的应用来说，连接Codis Proxy和连接原生的Redis Server没有明显的区别，上层应用可以像使用单机的Redis一样使用，Codis底层会处理请求的转发，不停机的数据迁移等工作，所有后边的一切事情，对于前面客户端来说是透明的，可以简单的认为后边连接是一个内存无限大的Redis服务。<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis和Memcache是当下最流行的Cache技术，都是可基于内存的Cache，读写效率高。</p><p>Redis已经是一个必不可少的部件，丰富的数据结构和超高的性能以及简单的协议，让Redis能够很好的作为数据库的上游缓存层。当然我们的项目中也使用了Redis进行Cache。Redis的优点有许多，这里我就不多做说明，主要列出下列几点Redis不足的地方。</p><p>Redis缺点：</p><ol><li>耗内存。尽管Redis对一些数据结构采用了压缩算法存储，但占用内存量还是过高。</li><li>Redis的单点问题。单点Redis容量大小总受限于内存，在业务对性能要求比较高的情况下，单个Redis显然无法满足我们的需求。</li></ol><p>对于单点Redis问题我们自然想到进行分布式扩容，目前市面上有类似：</p><ul><li>Redis自带的Cluster（官方不推荐使用）</li><li>Twitter的Twemproxy</li><li>豌豆荚工程师开发的Codis（和Codis升级后的RebornDB）</li></ul><p>至于选择是Twemproxy还是Codis看各个业务自己的需求，目前博主项目使用的就是Codis。</p><p>为什么选择Codis：</p><ul><li>业务需要，数据可能需要迁移，机器横向扩容</li><li>经过线上测试，Codis的升级版Reborn在pipline操作的性能比Codis慢了几十倍</li></ul><p>附上几个链接：</p><ol><li><a href="http://www.voidcn.com/blog/wuliusir/article/p-5783182.html" target="_blank" rel="external">Redis常见集群方案、Codis实践及与Twemproxy比较</a></li><li><a href="https://github.com/CodisLabs/codis/issues/309" target="_blank" rel="external">codis,redis,twemproxy三者对比</a></li></ol><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Codis的安装请参考官方步骤：<a href="https://github.com/CodisLabs/codis/blob/release2.0/doc/tutorial_zh.md#build-codis-proxy--codis-config" target="_blank" rel="external">Build Codis</a></p><p>简要步骤：</p><ol><li>安装Go</li><li>使用Go获取Codis代码</li><li>Go编译Codis代码</li></ol><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>Codis的部署可参考官网的步骤：<a href="https://github.com/CodisLabs/codis/blob/release2.0/doc/tutorial_zh.md#部署" target="_blank" rel="external">Codis部署</a></p><p>博主这里有一个一键执行的脚本示例大家可以参考：<a href="https://github.com/mastery001/codis-spring-java/tree/master/sample" target="_blank" rel="external">Codis sample</a></p><p><strong>Notes:</strong>脚本中的配置需要改为自己的zookeeper地址和一些Redis服务IP</p><h2 id="config-ini"><a href="#config-ini" class="headerlink" title="config.ini"></a>config.ini</h2><blockquote><p>作用：基础配置，zookeeper地址以及proxy_id等</p></blockquote><ol><li>coordinator：可选择etcd或者zookeeper，示例中的是zookeeper，这里只介绍zookeeper的配置，至于etcd的配置请参考官方文档</li><li>zk地址：host:ip 示例：zk=192.168.0.123:2181  如果有多个zk，则以逗号<code>,</code>分隔</li><li>product：产品名称, 这个Codis集群的名字, 可以认为是命名空间, 不同命名空间的Codis没有交集 </li><li>dashboard_addr：dashboard 服务的地址, CLI 的所有命令都依赖于 dashboard 的 RESTful API, 所以必须启动，一般ip配置为当前主机，port默认配置为18087</li><li>proxy_id：代理的id，不同机器的代理id不能相同</li></ol><h2 id="start-dashboard-sh"><a href="#start-dashboard-sh" class="headerlink" title="start_dashboard.sh"></a>start_dashboard.sh</h2><blockquote><p>作用：启动dashboard</p></blockquote><p>一般不用修改，但是当config.ini中的dashboard_addr配置的port不是18087时，需要将该shell中的port改为相同的port</p><h2 id="start-redis-sh"><a href="#start-redis-sh" class="headerlink" title="start_redis.sh"></a>start_redis.sh</h2><blockquote><p>作用：启动Redis Server</p></blockquote><p>示例中启动了四个codis-server(即Redis Server)，开启个数各自行调整，另外Redis的conf使用的是当前目录下redis_conf中的配置，可自行修改</p><h2 id="add-group-sh"><a href="#add-group-sh" class="headerlink" title="add_group.sh"></a>add_group.sh</h2><blockquote><p>作用：为Redis Server分组</p></blockquote><p>替换配置中的host和port，为codis-server的host和ip。根据业务需要进行合理的分组，可配置多个组</p><h2 id="initslot-sh"><a href="#initslot-sh" class="headerlink" title="initslot.sh"></a>initslot.sh</h2><blockquote><p>作用：初始化slot</p></blockquote><p>这一步非常重要，为了让缓存均匀的分布到每个codis-server中，在初始化的时候就需要将slot进行均匀分配。</p><p>最佳分配公式： 1024 / group个数</p><p>如有6个group，则可以按如下分配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">../bin/codis-config -c  config.ini slot range-set 0 170 1 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 171 341 2 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 342 512 3 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 513 693 4 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 694 864 5 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 865 1023 6 online</span><br></pre></td></tr></table></figure><h2 id="start-proxy-sh"><a href="#start-proxy-sh" class="headerlink" title="start_proxy.sh"></a>start_proxy.sh</h2><blockquote><p>作用：启用代理</p></blockquote><ul><li>—addr：配置访问codis的ip和port</li><li>—http-addr：codis的监控ip和port</li></ul><p>完成上面的步骤后即可在浏览器下访问：<a href="http://localhost:18087/admin" target="_blank" rel="external">http://localhost:18087/admin</a> 进行查看codis的状态</p><p>Dashboard<br><img src="/images/codis/dashboard.png" alt="dashboard"></p><p>Server_group<br><img src="/images/codis/server_group.png" alt="server_group"></p><p>Slots<br><img src="/images/codis/slots.png" alt="slots"></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol><li>初始化slot时未全部分配至所有group</li></ol><p>这个问题博主在第一次使用的时候遇到过，分配了6个group，但是在初始化slot的时候配置是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../bin/codis-config -c  config.ini slot range-set 0 511 1 online</span><br><span class="line">../bin/codis-config -c  config.ini slot range-set 512 1023 2 online</span><br></pre></td></tr></table></figure><p>只分配了两个group，这样导致key只能存储在前两个group中，另外4个group都不会存储了。</p><p><strong>解决方案</strong>：</p><ul><li>(1)执行Auto Rebalance</li></ul><p>在Dashboard界面中找到Migrate Status，点击Auto Rebalance指令，当key的数量特别多且占用内存很大时迁移时间需要很久。<br><img src="/images/codis/migrate.png" alt="migrate"></p><ul><li>(2)重新分配slot</li></ul><p>具体执行方式请google解决，我尚未尝试过</p><h1 id="For-Java-Users"><a href="#For-Java-Users" class="headerlink" title="For Java Users"></a>For Java Users</h1><blockquote><p>Codis的作者开发了新一代的升级版Codis—Reborn，并为Java开发者提供了相应的<a href="https://github.com/CodisLabs/jodis" target="_blank" rel="external">jodis</a>和<a href="https://github.com/reborndb/reborn-java" target="_blank" rel="external">Reborn-java</a></p></blockquote><p>这里博主向大家推荐一个在Reborn-java的基础上对Spring-data-redis的支持的<a href="https://github.com/mastery001/codis-spring-java" target="_blank" rel="external">codis-spring-java</a></p><ul><li>通过简单的配置即可与Spring-data-redis进行兼容</li><li>配置zk地址即可自行管理Redis连接池</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Codis是一个分布式的Redis解决方案，对于上层的应用来说，连接Codis Proxy和连接原生的Redis Server没有明显的区别，上层应用可以像使用单机的Redis一样使用，Codis底层会处理请求的转发，不停机的数据迁移等工作，所有后边的一切事情，对于前面客户端来说是透明的，可以简单的认为后边连接是一个内存无限大的Redis服务。&lt;br&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://blog.ziwenzou.com/categories/Knowledge/"/>
    
    
      <category term="cache" scheme="http://blog.ziwenzou.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>字节数组的妙用</title>
    <link href="http://blog.ziwenzou.com/2016/07/26/2016-07-26-byte_cache/"/>
    <id>http://blog.ziwenzou.com/2016/07/26/2016-07-26-byte_cache/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2017-11-11T14:59:16.361Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机高级语言中，字节属于最小单位，例如在Java中，int占用4个字节，long占用8个字节等。基本上所有基本类型(包括String)都可以转换成字节，那么这到底有何作用，本篇博客主要是记录了我使用字节数组的经验，希望可以给大家提供一些思路。</p><a id="more"></a><h1 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h1><h2 id="缓存类型大小分析"><a href="#缓存类型大小分析" class="headerlink" title="缓存类型大小分析"></a>缓存类型大小分析</h2><p>在实际开发中，经常会用到本地缓存，或使用<code>Redis</code>或者<code>Memcached</code>来作分布式缓存,Java一般存入缓存中的对象无非是以下几种:</p><ol><li>序列化的Java对象：一个Java对象序列化后所占用的字节是按对象中属性个数，方法个数，以及属性的值决定，最小也需要几百个字节来存储，大的话可能需要几万个字节</li><li>String(可能是json串)：占用字节由字符串的长度决定</li><li><p>规则的byte[]数组：占用字节由数组长度决定，相比较于String来说，基本类型转换成固定字节的数组，而不是转换成内容长度的String，故字节数组所占用的字节比String更少</p><p><strong>上述的占用字节数是不考虑Redis或Memcached内部会做出的压缩操作。</strong></p><p>从上面三种对象分别占用的字节数来分析得出结论：</p><ol><li>在大量的缓存数据(亿级以上)的情况下，为了提高空间利用率，切勿将Java对象当做缓存的内容</li><li>字节数组所需空间最少</li></ol></li></ol><h2 id="字节数组的使用实例"><a href="#字节数组的使用实例" class="headerlink" title="字节数组的使用实例"></a>字节数组的使用实例</h2><blockquote><p>下述场景属于个人虚构的</p></blockquote><p>场景：在电影票系统数据库中，电影院id为int类型，电影id为int类型，上映时间为long类型，电影名称为String类型，现有10亿数据，需要将这些数据存入<code>Redis</code>中。</p><p>分析：10亿数组采用Java对象作为存储数据显然是不可取，而上映时间为long类型，可能出现数字非常大的id，所以准备采用字节数组形式存储。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存结构为：采用hash结构，电影院id为key，电影id为hashKey，value为字节数组，内容为：上映时间+电影名称，存储为大小为8+String.getBytes().length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*代码只贴出了生成字节数组的部分，至于字节数组转换成值的部分大家可以自行实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 以下代码主要获取value，即字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes(<span class="keyword">long</span> startTime , String name) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] strBytes = name.getBytes();</span><br><span class="line"><span class="keyword">int</span> strLength = strBytes.length;</span><br><span class="line"><span class="keyword">byte</span>[] cache = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> + strLength];</span><br><span class="line">longToByteArray(startTime , cache , <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strLength ; i++) &#123;</span><br><span class="line">cache[index + i] = strBytes[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将long类型的数转换成字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longToByteArray</span><span class="params">(<span class="keyword">long</span> value, <span class="keyword">byte</span>[] byteArray, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">byteArray[start] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">56</span>);<span class="comment">// 取最高8位放到0下标</span></span><br><span class="line">byteArray[start + <span class="number">1</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">48</span>);<span class="comment">// 取最高8位放到0下标</span></span><br><span class="line">byteArray[start + <span class="number">2</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">40</span>);<span class="comment">// 取最高8位放到0下标</span></span><br><span class="line">byteArray[start + <span class="number">3</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">32</span>);<span class="comment">// 取最高8位放到0下标</span></span><br><span class="line">byteArray[start + <span class="number">4</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">24</span>);<span class="comment">// 取最高8位放到0下标</span></span><br><span class="line">byteArray[start + <span class="number">5</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 取次高8为放到1下标</span></span><br><span class="line">byteArray[start + <span class="number">6</span>] = (<span class="keyword">byte</span>) (value &gt;&gt;&gt; <span class="number">8</span>); <span class="comment">// 取次低8位放到2下标</span></span><br><span class="line">byteArray[start + <span class="number">7</span>] = (<span class="keyword">byte</span>) (value); <span class="comment">// 取最低8位放到3下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节数组转换成long类型</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">byteArrayToLong</span><span class="params">(<span class="keyword">byte</span>[] byteArray, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> i = a.length - <span class="number">1</span>, j = start + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--, j--) &#123;<span class="comment">// 从b的尾部(即int值的低位)开始copy数据</span></span><br><span class="line"><span class="keyword">if</span> (j &gt;= start)</span><br><span class="line">a[i] = byteArray[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[i] = <span class="number">0</span>;<span class="comment">// 如果b.length不足4,则将高位补0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意此处和byte数组转换成int的区别在于，下面的转换中要将先将数组中的元素转换成long型再做移位操作，</span></span><br><span class="line"><span class="comment">// 若直接做位移操作将得不到正确结果，因为Java默认操作数字时，若不加声明会将数字作为int型来对待，此处必须注意。</span></span><br><span class="line"><span class="keyword">long</span> v0 = (<span class="keyword">long</span>) (a[<span class="number">0</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>;<span class="comment">// &amp;0xff将byte值无差异转成int,避免Java自动类型提升后,会保留高位的符号位</span></span><br><span class="line"><span class="keyword">long</span> v1 = (<span class="keyword">long</span>) (a[<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>;</span><br><span class="line"><span class="keyword">long</span> v2 = (<span class="keyword">long</span>) (a[<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>;</span><br><span class="line"><span class="keyword">long</span> v3 = (<span class="keyword">long</span>) (a[<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line"><span class="keyword">long</span> v4 = (<span class="keyword">long</span>) (a[<span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line"><span class="keyword">long</span> v5 = (<span class="keyword">long</span>) (a[<span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">long</span> v6 = (<span class="keyword">long</span>) (a[<span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">long</span> v7 = (<span class="keyword">long</span>) (a[<span class="number">7</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line"><span class="keyword">return</span> v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>当使用本地缓存需要提高内存的利用率，也是可以使用字节数组的。</em></strong></p><p>推荐一篇博客：<a href="http://www.2cto.com/kf/201308/235099.html" target="_blank" rel="external">java Byte和各数据类型(short,int,long,float,double)之间的转换</a></p><h2 id="字节数组的作用"><a href="#字节数组的作用" class="headerlink" title="字节数组的作用"></a>字节数组的作用</h2><ul><li>提高空间利用率</li><li>压缩内容，在网络传输时，能有效压缩传输数据的大小，从而提高效率</li></ul><p>以上内容纯属个人见解，有不妥的地方请各位大神指正，谢谢！ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机高级语言中，字节属于最小单位，例如在Java中，int占用4个字节，long占用8个字节等。基本上所有基本类型(包括String)都可以转换成字节，那么这到底有何作用，本篇博客主要是记录了我使用字节数组的经验，希望可以给大家提供一些思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://blog.ziwenzou.com/categories/Knowledge/"/>
    
    
      <category term="memory" scheme="http://blog.ziwenzou.com/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>Git协同开发的那点事</title>
    <link href="http://blog.ziwenzou.com/2016/07/19/2016-07-19-develop_by_git/"/>
    <id>http://blog.ziwenzou.com/2016/07/19/2016-07-19-develop_by_git/</id>
    <published>2016-07-18T16:00:00.000Z</published>
    <updated>2017-11-11T14:59:21.958Z</updated>
    
    <content type="html"><![CDATA[<p>随着分布式和开源这些概念的不断普及，现在有大部分的开发者都在用Git管理开源项目、个人项目和公司的项目开发。本篇博客主要是研究实际在使用Git进行多人协作开发过程中的一些场景和解决方案。</p><a id="more"></a><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p></blockquote><p>网上有许多介绍Git的博客等，下面就附上链接：</p><ul><li><a href="http://baike.baidu.com/link?url=Vxrrj2D-qCxXYet_dNwTvM9w7FRyuRWdkQz7zkrzSmGP-C8n5Ql0CwJCtPBWpIjhmAkGVcDficopCEssX2P7zo2eXnbJlrZXH9zRksqTuEe" target="_blank" rel="external">Git(百度百科)</a></li><li><a href="http://blog.csdn.net/wengpingbo/article/details/8985132" target="_blank" rel="external">为什么用Git</a></li><li><a href="http://blog.jobbole.com/31444/" target="_blank" rel="external">Git和SVN的区别</a></li></ul><h1 id="协同开发场景分析"><a href="#协同开发场景分析" class="headerlink" title="协同开发场景分析"></a>协同开发场景分析</h1><h2 id="场景一：开发分支错误"><a href="#场景一：开发分支错误" class="headerlink" title="场景一：开发分支错误"></a>场景一：开发分支错误</h2><p>项目来了个<code>需求1</code>，从<code>develop</code>分支中拉分支<code>A</code>进行开发；开发的中途，又来了一个紧急<code>需求2</code>，于是我就直接在<code>A</code>分支中开发<code>需求2</code>；直到发现不能在<code>A</code>分支中开发<code>需求2</code>的时候<code>需求2</code>的代码已经<code>commit</code>了几次了。</p><p>如下图提交：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m1-m2-m3-m4-m5</span><br></pre></td></tr></table></figure><p>m1、m2、m5是需求1的代码，m3和m4是需求2的代码</p><p><strong><em>解决方案：</em></strong></p><p><strong>假设m3和m4是commit id为0bda20e和1a04d5f</strong></p><p>利用cherry-pick和revert:</p><ol><li>从develop分支创建新分支B：<code>git checkout B</code></li><li>将A分支中的需求2的commit复制到分支B：<code>git cherry-pick 0bda20e 1a04d5f</code> </li><li>撤销在A分支中开发的需求2：<code>git checkout A</code> 和 <code>git revert 0bda20e 1a04d5f</code></li></ol><p>附上cherry-pick和revert的一些博客：</p><ul><li><a href="http://yijiebuyi.com/blog/0e65f4a59a1cfa05c5b30ccb6c2f413d.html" target="_blank" rel="external">git cherry-pick</a></li><li><a href="http://dmouse.iteye.com/blog/1797267" target="_blank" rel="external">git引发的血案（cherry-pick找回丢失的commit)</a></li><li><a href="http://www.cnblogs.com/0616--ataozhijia/p/3709917.html" target="_blank" rel="external">git revert 用法</a></li></ul><h2 id="场景二：分支进度不一致"><a href="#场景二：分支进度不一致" class="headerlink" title="场景二：分支进度不一致"></a>场景二：分支进度不一致</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1-m2-m3-m4-m5-m6(master)</span><br><span class="line">       \</span><br><span class="line">       f1-f2-f3-f4-f5(feature)</span><br></pre></td></tr></table></figure><p>多人协作开发时，你需要开发一个新功能，于是你从<code>master</code>上的<code>commit3</code>开始拉了一个分支<code>feature</code>，可是这个新功能开发周期很长，等到你完成的时候，<code>master</code>已经提交到<code>m6</code>了。如上图所示。</p><p><strong><em>解决方案：</em></strong></p><p>使用rebase：</p><ol><li>切换到分支feature：<code>git checkout feature</code></li><li>rebase到master：<code>git rebase master</code></li><li>有冲突解决后执行：<code>git rebase --continue</code></li></ol><p>分支树则变成(如下图所示)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1-m2-m3-m4-m5-m6(master)</span><br><span class="line">                \</span><br><span class="line">                f1-f2-f3-f4-f5(feature)</span><br></pre></td></tr></table></figure><p>附上rebase的一些博客：</p><ul><li><a href="http://blog.csdn.net/hudashi/article/details/7664631" target="_blank" rel="external">git rebase简介(基本篇)</a></li><li><a href="https://linux.cn/article-4046-1.html" target="_blank" rel="external">git rebase让时光倒流</a></li><li><a href="http://blog.csdn.net/carolzhang8406/article/details/49761665" target="_blank" rel="external">cherry-pick, merge, rebase</a></li><li><a href="http://blog.chinaunix.net/uid-27714502-id-3436696.html" target="_blank" rel="external">git-rebase(认真看，分析很到位)</a></li></ul><p>暂时先发这么多，到时再补上。有错误的地方麻烦各位指正。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着分布式和开源这些概念的不断普及，现在有大部分的开发者都在用Git管理开源项目、个人项目和公司的项目开发。本篇博客主要是研究实际在使用Git进行多人协作开发过程中的一些场景和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://blog.ziwenzou.com/categories/git/"/>
    
    
      <category term="git" scheme="http://blog.ziwenzou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>个人git项目推荐</title>
    <link href="http://blog.ziwenzou.com/2016/07/18/2016-07-18-myself_project/"/>
    <id>http://blog.ziwenzou.com/2016/07/18/2016-07-18-myself_project/</id>
    <published>2016-07-17T16:00:00.000Z</published>
    <updated>2017-11-11T14:59:27.132Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"></div><p>学习了Java也有好几年了，在这过程中也开发了几个类似于框架或工具包的项目，在这里就王婆卖瓜一下，觉得还行的话不妨可以Download下来看看。</p><a id="more"></a><h1 id="Autumn-Framework"><a href="#Autumn-Framework" class="headerlink" title="Autumn Framework"></a>Autumn Framework</h1><p>Autumn是基于Servlet的Action Mapping映射、依赖注入和数据库的ORM关系映射实现的JavaWeb框架。</p><p>本次设计主要采用了单例模式，工厂模式，适配器模式、模板方法模式、代理模式的组合设计来完成的。</p><ul><li>采用了Struts的action的基本原理，采用通过配置action（action.xml）的方式来进行前台与控制层的交互。对HttpServletRequest对象进行重写，用于代理request对象的方法进行表单收集操作。并且集成了FileUpload组件的文件上传，Action可通过配置注解自动对表单进行收集成对象！</li><li>采用了Spring的IOC的思想，通过配置beans.xml文件对dao层和service层对象进行注入，并且内部细节隐藏，可直接通过工厂获取对应的对象！</li></ul><p>github地址：<a href="https://github.com/mastery001/Autumn" target="_blank" rel="external">https://github.com/mastery001/Autumn</a></p><h1 id="reactor-http"><a href="#reactor-http" class="headerlink" title="reactor-http"></a>reactor-http</h1><p>该项目基于Apache http组件之上进行进一步包装使用，将http请求事件进行垂直切割，以完成http调用监控、统计、降级等作用。</p><ul><li>0.x版本：适配的是apache http3.1的版本</li><li>1.x版本：适配的是apache http4.x的版本</li></ul><p>github地址：<a href="https://github.com/mastery001/reactor-http" target="_blank" rel="external">https://github.com/mastery001/reactor-http</a></p><h1 id="codis-spring-java"><a href="#codis-spring-java" class="headerlink" title="codis-spring-java"></a>codis-spring-java</h1><p>该项目是基于codis作者提供的<a href="https://github.com/reborndb/reborn-java" target="_blank" rel="external">Reborn-java</a>添加了如下功能：</p><ul><li>适配Spring-data-redis</li><li>当zk连接状态变化时，判断是否CONNECTED或RECONNECTED，若是则重新加载pools</li><li>添加password选项</li></ul><p>github地址：<a href="https://github.com/mastery001/codis-spring-java" target="_blank" rel="external">https://github.com/mastery001/codis-spring-java</a></p><h1 id="Dolphin-Voice-Language"><a href="#Dolphin-Voice-Language" class="headerlink" title="Dolphin-Voice-Language"></a>Dolphin-Voice-Language</h1><p>该项目基于openjdk中编译代码(参考了大量的编译代码)逐步实现的解释型语言dv，有助于理解编译原理(词法分析，语法分析)</p><p>github地址：<a href="https://github.com/mastery001/Dolphin-Voice-Language" target="_blank" rel="external">https://github.com/mastery001/Dolphin-Voice-Language</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;toc&quot;&gt;&lt;/div&gt;

&lt;p&gt;学习了Java也有好几年了，在这过程中也开发了几个类似于框架或工具包的项目，在这里就王婆卖瓜一下，觉得还行的话不妨可以Download下来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="Project" scheme="http://blog.ziwenzou.com/categories/Project/"/>
    
    
      <category term="framework" scheme="http://blog.ziwenzou.com/tags/framework/"/>
    
  </entry>
  
</feed>
